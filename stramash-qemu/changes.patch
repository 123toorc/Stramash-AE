diff -ur archive/stramash/Stramash-QEMU/accel/tcg/cpu-exec.c qemu-stramash/accel/tcg/cpu-exec.c
--- archive/stramash/Stramash-QEMU/accel/tcg/cpu-exec.c	2024-05-13 16:45:02.379796730 +0100
+++ qemu-stramash/accel/tcg/cpu-exec.c	2024-04-04 01:17:08.371416056 +0100
@@ -844,7 +844,7 @@
         return;
     }
 
-    qemu_printf("Host - Guest clock  %"PRIi64" ms\n",
+    qemu_printf("Host -  Guest clock = %"PRIi64" ms\n",
                 (cpu_get_clock() - icount_get()) / SCALE_MS);
     if (icount_align_option) {
         qemu_printf("Max guest delay     %"PRIi64" ms\n",
diff -ur archive/stramash/Stramash-QEMU/accel/tcg/cputlb.c qemu-stramash/accel/tcg/cputlb.c
--- archive/stramash/Stramash-QEMU/accel/tcg/cputlb.c	2024-05-13 16:45:02.379796730 +0100
+++ qemu-stramash/accel/tcg/cputlb.c	2024-04-04 01:17:08.375416093 +0100
@@ -59,6 +59,13 @@
 # define DEBUG_TLB_LOG_GATE 0
 #endif
 
+#pragma GCC diagnostic push 
+#pragma GCC diagnostic ignored "-Wunused-variable"
+static uint64_t tlb_miss_counter;
+static uint64_t page_fault_counter;
+
+#pragma GCC diagnostic pop 
+
 #define tlb_debug(fmt, ...) do { \
     if (DEBUG_TLB_LOG_GATE) { \
         qemu_log_mask(CPU_LOG_MMU, "%s: " fmt, __func__, \
@@ -1745,6 +1752,12 @@
     }
 }
 
+void tlb_plugin_read_counters(struct qemu_plugin_page_counter *ctr)
+{
+    ctr->tlb_miss_counter = tlb_miss_counter;
+    ctr->page_fault_counter = page_fault_counter;
+}
+
 #endif
 
 /* Probe for a read-modify-write atomic operation.  Do not allow unaligned
diff -ur archive/stramash/Stramash-QEMU/accel/tcg/tcg-accel-ops-icount.c qemu-stramash/accel/tcg/tcg-accel-ops-icount.c
--- archive/stramash/Stramash-QEMU/accel/tcg/tcg-accel-ops-icount.c	2024-05-13 16:45:02.379796730 +0100
+++ qemu-stramash/accel/tcg/tcg-accel-ops-icount.c	2024-04-04 01:17:08.375416093 +0100
@@ -48,9 +48,11 @@
         deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL,
                                               QEMU_TIMER_ATTR_ALL);
         /* Check realtime timers, because they help with input processing */
-        deadline = qemu_soonest_timeout(deadline,
-                qemu_clock_deadline_ns_all(QEMU_CLOCK_REALTIME,
-                                           QEMU_TIMER_ATTR_ALL));
+		//FOR STRAMASH WE DON'T CHECK REAL TIME
+        
+        // deadline = qemu_soonest_timeout(deadline,
+        //        qemu_clock_deadline_ns_all(QEMU_CLOCK_REALTIME,
+        //                                   QEMU_TIMER_ATTR_ALL));
 
         /*
          * Maintain prior (possibly buggy) behaviour where if no deadline
diff -ur archive/stramash/Stramash-QEMU/backends/hostmem-ram.c qemu-stramash/backends/hostmem-ram.c
--- archive/stramash/Stramash-QEMU/backends/hostmem-ram.c	2024-05-13 16:45:02.387796806 +0100
+++ qemu-stramash/backends/hostmem-ram.c	2024-05-13 02:27:40.136412071 +0100
@@ -9,7 +9,7 @@
  * This work is licensed under the terms of the GNU GPL, version 2 or later.
  * See the COPYING file in the top-level directory.
  */
-
+#include <unistd.h>
 #include "qemu/osdep.h"
 #include "sysemu/hostmem.h"
 #include "qapi/error.h"
@@ -19,6 +19,7 @@
 static void
 ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
+    printf("Initializing memory backend this way with %s\n", __func__ );
     char *name;
 
     if (!backend->size) {
@@ -27,8 +28,12 @@
     }
 
     name = host_memory_backend_get_name(backend);
-    memory_region_init_ram_shared_nomigrate(&backend->mr, OBJECT(backend), name,
-                           backend->size, backend->share, errp);
+    char filename[256];
+    int pid = getpid();
+    sprintf(filename, "/dev/shm/ddr-share_%d", pid);
+    memory_region_init_ram_from_file(&backend->mr, OBJECT(backend), name, backend->size, 0, RAM_SHARED, filename, false ,errp);
+//    memory_region_init_ram_shared_nomigrate(&backend->mr, OBJECT(backend), name,
+//                           backend->size, backend->share, errp);
     g_free(name);
 }
 
Only in qemu-stramash: blobs
Only in qemu-stramash: build.sh
Only in qemu-stramash/capstone: .appveyor.yml
Only in qemu-stramash/capstone: arch
Only in qemu-stramash/capstone: bindings
Only in qemu-stramash/capstone: capstone-config.cmake.in
Only in qemu-stramash/capstone: capstone.pc.in
Only in qemu-stramash/capstone: ChangeLog
Only in qemu-stramash/capstone: .clang-format
Only in qemu-stramash/capstone: CMakeLists.txt
Only in qemu-stramash/capstone: cmake.sh
Only in qemu-stramash/capstone: COMPILE_CMAKE.TXT
Only in qemu-stramash/capstone: COMPILE_MSVC.TXT
Only in qemu-stramash/capstone: COMPILE.TXT
Only in qemu-stramash/capstone: config.mk
Only in qemu-stramash/capstone: contrib
Only in qemu-stramash/capstone: CREDITS.TXT
Only in qemu-stramash/capstone: cs.c
Only in qemu-stramash/capstone: cs_priv.h
Only in qemu-stramash/capstone: cstool
Only in qemu-stramash/capstone: docs
Only in qemu-stramash/capstone: .editorconfig
Only in qemu-stramash/capstone: functions.mk
Only in qemu-stramash/capstone: .git
Only in qemu-stramash/capstone: .gitattributes
Only in qemu-stramash/capstone: .github
Only in qemu-stramash/capstone: .gitignore
Only in qemu-stramash/capstone: HACK.TXT
Only in qemu-stramash/capstone: include
Only in qemu-stramash/capstone: LEB128.h
Only in qemu-stramash/capstone: LICENSE_LLVM.TXT
Only in qemu-stramash/capstone: LICENSE.TXT
Only in qemu-stramash/capstone: Makefile
Only in qemu-stramash/capstone: make.sh
Only in qemu-stramash/capstone: MathExtras.h
Only in qemu-stramash/capstone: MCDisassembler.h
Only in qemu-stramash/capstone: MCFixedLenDisassembler.h
Only in qemu-stramash/capstone: MCInst.c
Only in qemu-stramash/capstone: MCInst.h
Only in qemu-stramash/capstone: MCInstrDesc.c
Only in qemu-stramash/capstone: MCInstrDesc.h
Only in qemu-stramash/capstone: MCRegisterInfo.c
Only in qemu-stramash/capstone: MCRegisterInfo.h
Only in qemu-stramash/capstone: msvc
Only in qemu-stramash/capstone: nmake.bat
Only in qemu-stramash/capstone: packages
Only in qemu-stramash/capstone: pkgconfig.mk
Only in qemu-stramash/capstone: README.md
Only in qemu-stramash/capstone: RELEASE_NOTES
Only in qemu-stramash/capstone: SPONSORS.TXT
Only in qemu-stramash/capstone: SStream.c
Only in qemu-stramash/capstone: SStream.h
Only in qemu-stramash/capstone: suite
Only in qemu-stramash/capstone: tests
Only in qemu-stramash/capstone: TODO
Only in qemu-stramash/capstone: .travis.yml
Only in qemu-stramash/capstone: utils.c
Only in qemu-stramash/capstone: utils.h
Only in qemu-stramash/capstone: windows
Only in qemu-stramash/capstone: windowsce
Only in qemu-stramash/capstone: xcode
Only in qemu-stramash/contrib/plugins: cache.c.bak
Only in qemu-stramash/contrib/plugins: cache-sim.bak
Only in qemu-stramash/contrib/plugins: cache-sim.c
diff -ur archive/stramash/Stramash-QEMU/contrib/plugins/hotpages.c qemu-stramash/contrib/plugins/hotpages.c
--- archive/stramash/Stramash-QEMU/contrib/plugins/hotpages.c	2024-05-13 16:45:02.431797223 +0100
+++ qemu-stramash/contrib/plugins/hotpages.c	2024-02-10 22:37:09.453853273 +0000
@@ -112,6 +112,11 @@
     struct qemu_plugin_hwaddr *hwaddr = qemu_plugin_get_hwaddr(meminfo, vaddr);
     uint64_t page;
     PageCounters *count;
+    
+    uint64_t phy_addr = qemu_plugin_hwaddr_phys_addr(hwaddr);
+
+    if (phy_addr >= 0x1000000000ULL && phy_addr < 0x1001000000ULL)
+        printf("here we go\n");
 
     /* We only get a hwaddr for system emulation */
     if (track_io) {
diff -ur archive/stramash/Stramash-QEMU/contrib/plugins/hwprofile.c qemu-stramash/contrib/plugins/hwprofile.c
--- archive/stramash/Stramash-QEMU/contrib/plugins/hwprofile.c	2024-05-13 16:45:02.431797223 +0100
+++ qemu-stramash/contrib/plugins/hwprofile.c	2024-03-16 01:53:08.594899811 +0000
@@ -1,243 +1,249 @@
 /*
  * Copyright (C) 2020, Alex BennÃ©e <alex.bennee@linaro.org>
+ * usage example:
  *
- * HW Profile - breakdown access patterns for IO to devices
+ * #if defined(CONFIG_X86_64)
+ *   #define ARCH_TRIGGER_ADDR = 0x0f200000ULL
+ * #elif defined(CONFIG_ARM64)
+ *   #define ARCH_TRIGGER_ADDR = 0x1200000000ULL
+ * #endif
+ *
+ * void *trigger_address = memremap(ARCH_TRIGGER_ADDR, 0x10, MEMREMAP_WB);
+ * memset(trigger_address, 0, 0x10);
+ * memunmap(trigger_address);
  *
  * License: GNU GPL, version 2 or later.
  *   See the COPYING file in the top-level directory.
  */
-
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 #include <inttypes.h>
 #include <assert.h>
 #include <stdlib.h>
-#include <inttypes.h>
-#include <string.h>
 #include <unistd.h>
+#include <string.h>
 #include <stdio.h>
 #include <glib.h>
-
+#include <sys/mman.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/un.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <math.h>
 #include <qemu-plugin.h>
 
 QEMU_PLUGIN_EXPORT int qemu_plugin_version = QEMU_PLUGIN_VERSION;
 
-#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
-
-typedef struct {
-    uint64_t cpu_read;
-    uint64_t cpu_write;
-    uint64_t reads;
-    uint64_t writes;
-} IOCounts;
-
-typedef struct {
-    uint64_t off_or_pc;
-    IOCounts counts;
-} IOLocationCounts;
-
-typedef struct {
-    const char *name;
-    uint64_t   base;
-    IOCounts   totals;
-    GHashTable *detail;
-} DeviceCounts;
-
-static GMutex lock;
-static GHashTable *devices;
-
-/* track the access pattern to a piece of HW */
-static bool pattern;
-/* track the source address of access to HW */
-static bool source;
-/* track only matched regions of HW */
-static bool check_match;
-static gchar **matches;
-
-static enum qemu_plugin_mem_rw rw = QEMU_PLUGIN_MEM_RW;
-
-static inline bool track_reads(void)
+typedef enum
 {
-    return rw == QEMU_PLUGIN_MEM_RW || rw == QEMU_PLUGIN_MEM_R;
-}
-
-static inline bool track_writes(void)
-{
-    return rw == QEMU_PLUGIN_MEM_RW || rw == QEMU_PLUGIN_MEM_W;
-}
-
-static void plugin_init(void)
-{
-    devices = g_hash_table_new(NULL, NULL);
-}
+    PROF_ARCH_AARCH64,
+    PROF_ARCH_X86_64,
+    PROF_ARCH_INCOMPATIBLE
+} ProfileArch;
+
+static uint8_t icount_on;
+static bool enable_log;
+static uint64_t insn_count;
+static FILE *fp;
+static enum qemu_plugin_mem_rw rw = QEMU_PLUGIN_MEM_RW;
+static ProfileArch prof_arch;
+static uint32_t prof_cost;
+static char *shm_path;
+const uint64_t shm_size = 0x00100000;
+static void *shm_ptr;
+static uint64_t prof_base;
+static char *primesim_socket_path;
+static int primesim_socket_fd;
 
-static gint sort_cmp(gconstpointer a, gconstpointer b)
+int client_connect_socket(const char *server_socket_path)
 {
-    DeviceCounts *ea = (DeviceCounts *) a;
-    DeviceCounts *eb = (DeviceCounts *) b;
-    return ea->totals.reads + ea->totals.writes >
-           eb->totals.reads + eb->totals.writes ? -1 : 1;
-}
+    int client_sock, rc, len;
+    struct sockaddr_un server_sockaddr;
+    char buf[256];
+    memset(&server_sockaddr, 0, sizeof(struct sockaddr_un));
 
-static gint sort_loc(gconstpointer a, gconstpointer b)
-{
-    IOLocationCounts *ea = (IOLocationCounts *) a;
-    IOLocationCounts *eb = (IOLocationCounts *) b;
-    return ea->off_or_pc > eb->off_or_pc;
-}
+    /**************************************/
+    /* Create a UNIX domain stream socket */
+    /**************************************/
+    client_sock = socket(AF_UNIX, SOCK_STREAM, 0);
+    if (client_sock == -1)
+    {
+        printf("SOCKET ERROR = %s\n", strerror(errno));
+        exit(1);
+    }
 
-static void fmt_iocount_record(GString *s, IOCounts *rec)
-{
-    if (track_reads()) {
-        g_string_append_printf(s, ", %"PRIx64", %"PRId64,
-                               rec->cpu_read, rec->reads);
-    }
-    if (track_writes()) {
-        g_string_append_printf(s, ", %"PRIx64", %"PRId64,
-                               rec->cpu_write, rec->writes);
+    server_sockaddr.sun_family = AF_UNIX;
+    strcpy(server_sockaddr.sun_path, server_socket_path);
+    rc = connect(client_sock, (struct sockaddr *)&server_sockaddr, sizeof(struct sockaddr_un));
+    if (rc == -1)
+    {
+        printf("CONNECT ERROR = %s\n", strerror(errno));
+        close(client_sock);
+        exit(1);
     }
-}
 
-static void fmt_dev_record(GString *s, DeviceCounts *rec)
-{
-    g_string_append_printf(s, "%s, 0x%"PRIx64,
-                           rec->name, rec->base);
-    fmt_iocount_record(s, &rec->totals);
-    g_string_append_c(s, '\n');
+    return client_sock;
 }
 
-static void plugin_exit(qemu_plugin_id_t id, void *p)
+void client_send_message(int client_sock, uint64_t buf)
 {
-    g_autoptr(GString) report = g_string_new("");
-    GList *counts;
-
-    if (!(pattern || source)) {
-        g_string_printf(report, "Device, Address");
-        if (track_reads()) {
-            g_string_append_printf(report, ", RCPUs, Reads");
-        }
-        if (track_writes()) {
-            g_string_append_printf(report, ",  WCPUs, Writes");
-        }
-        g_string_append_c(report, '\n');
-    }
-
-    counts = g_hash_table_get_values(devices);
-    if (counts && g_list_next(counts)) {
-        GList *it;
-
-        it = g_list_sort(counts, sort_cmp);
-
-        while (it) {
-            DeviceCounts *rec = (DeviceCounts *) it->data;
-            if (rec->detail) {
-                GList *accesses = g_hash_table_get_values(rec->detail);
-                GList *io_it = g_list_sort(accesses, sort_loc);
-                const char *prefix = pattern ? "off" : "pc";
-                g_string_append_printf(report, "%s @ 0x%"PRIx64"\n",
-                                       rec->name, rec->base);
-                while (io_it) {
-                    IOLocationCounts *loc = (IOLocationCounts *) io_it->data;
-                    g_string_append_printf(report, "  %s:%08"PRIx64,
-                                           prefix, loc->off_or_pc);
-                    fmt_iocount_record(report, &loc->counts);
-                    g_string_append_c(report, '\n');
-                    io_it = io_it->next;
-                }
-            } else {
-                fmt_dev_record(report, rec);
-            }
-            it = it->next;
-        };
-        g_list_free(it);
-    }
-
-    qemu_plugin_outs(report->str);
+    int ret;
+    do
+    {
+        ret = write(client_sock, (void *)&buf, sizeof(buf));
+    } while (ret <= 0);
 }
-
-static DeviceCounts *new_count(const char *name, uint64_t base)
+void server_recv(int server_sock, uint64_t *buf)
 {
-    DeviceCounts *count = g_new0(DeviceCounts, 1);
-    count->name = name;
-    count->base = base;
-    if (pattern || source) {
-        count->detail = g_hash_table_new(NULL, NULL);
-    }
-    g_hash_table_insert(devices, (gpointer) name, count);
-    return count;
+    int ret = 0;
+    do
+    {
+        ret = read(server_sock, buf, sizeof(uint64_t));
+    } while (ret <= 0);
 }
 
-static IOLocationCounts *new_location(GHashTable *table, uint64_t off_or_pc)
+void client_close_socket(int socket_fd)
 {
-    IOLocationCounts *loc = g_new0(IOLocationCounts, 1);
-    loc->off_or_pc = off_or_pc;
-    g_hash_table_insert(table, (gpointer) off_or_pc, loc);
-    return loc;
+    close(socket_fd);
 }
 
-static void hwprofile_match_hit(DeviceCounts *rec, uint64_t off)
+static void plugin_init(void)
 {
-    g_autoptr(GString) report = g_string_new("hwprofile: match @ offset");
-    g_string_append_printf(report, "%"PRIx64", previous hits\n", off);
-    fmt_dev_record(report, rec);
-    qemu_plugin_outs(report->str);
+    icount_on = 1;
+    insn_count = 0;
 }
 
-static void inc_count(IOCounts *count, bool is_write, unsigned int cpu_index)
+static void plugin_exit(qemu_plugin_id_t id, void *p)
 {
-    if (is_write) {
-        count->writes++;
-        count->cpu_write |= (1 << cpu_index);
-    } else {
-        count->reads++;
-        count->cpu_read |= (1 << cpu_index);
-    }
-}
+    g_autofree gchar *out = g_strdup_printf("insns: %" PRIu64 "\n", insn_count);
+    qemu_plugin_outs(out);
+    munmap(shm_ptr, shm_size);
+    shm_unlink(shm_path);
+
+    if (1)
+    {
+        client_send_message(primesim_socket_fd, 8);
+        client_send_message(primesim_socket_fd, 8);
+        client_send_message(primesim_socket_fd, 8);
+        client_send_message(primesim_socket_fd, 8);
+        client_send_message(primesim_socket_fd, 8);
+        client_send_message(primesim_socket_fd, 8);
+
+        printf("done\n");
+    }
+    client_close_socket(primesim_socket_fd);
+}
+
+static void toggle_icount(void)
+{
+    icount_on = icount_on == 1 ? 0 : 1;
+}
+
+// int check_icount(void)
+// {
+//     if (!icount_on)
+//         return 1;
+//     else
+//         return 0;
+// }
+static int stramash_index = 0;
+static uint64_t stramash_bias = 0;
 
 static void vcpu_haddr(unsigned int cpu_index, qemu_plugin_meminfo_t meminfo,
                        uint64_t vaddr, void *udata)
 {
     struct qemu_plugin_hwaddr *hwaddr = qemu_plugin_get_hwaddr(meminfo, vaddr);
+    uint64_t insn_diff;
+    // if (!hwaddr || !qemu_plugin_hwaddr_is_io(hwaddr))
+    if (!hwaddr)
+        return;
+
+    uint64_t phy_addr = qemu_plugin_hwaddr_phys_addr(hwaddr);
+    uint64_t *haddr = (uint64_t *)udata;
+    bool c;
+    uint64_t delta_bias = 0;
+    // STRMASH TIMING MODEL
+    uint64_t bias = qemu_plugin_get_bias();
+    if (bias > stramash_bias)
+    {
+        delta_bias = bias - stramash_bias;
+        stramash_bias = bias;
+    }
+    if (icount_on)
+    {
+        insn_count += delta_bias;
+        stramash_index += 1;
+        c = qemu_plugin_mem_is_store(meminfo);
+        //		client_send_message(primesim_socket_fd, *haddr);
+        /*
+                if(stramash_index % 1000000 == 0)
+                {
+                //	printf("%d addr %lx type %lx\n",insn_count, phy_addr, c);
+                    //printf("it's time to sync\n");
+                    do
+                    {
+                        server_recv(primesim_socket_fd,&insn_diff);
+                        //printf("received %ld\n",insn_diff);
+                    }while(insn_diff != 22222);
+                    server_recv(primesim_socket_fd,&insn_diff);
+                    insn_count+=insn_diff;
+                    qemu_plugin_feedback(insn_diff);
+                }
+               
+        /*
+        if(stramash_index % 1000000 == 0)
+        {
+            // printf("icount local %ld bias %ld icount real %ld feedback %ld\n",insn_count, bias, qemu_plugin_get_icount(), insn_diff);
+        }*/
+        client_send_message(primesim_socket_fd, insn_count);
+
+        client_send_message(primesim_socket_fd, c);
+        client_send_message(primesim_socket_fd, phy_addr);
+    }
 
-    if (!hwaddr || !qemu_plugin_hwaddr_is_io(hwaddr)) {
+    if (phy_addr >> 8 != prof_base)
+    {
         return;
-    } else {
-        const char *name = qemu_plugin_hwaddr_device_name(hwaddr);
-        uint64_t off = qemu_plugin_hwaddr_phys_addr(hwaddr);
-        bool is_write = qemu_plugin_mem_is_store(meminfo);
-        DeviceCounts *counts;
-
-        g_mutex_lock(&lock);
-        counts = (DeviceCounts *) g_hash_table_lookup(devices, name);
-
-        if (!counts) {
-            uint64_t base = vaddr - off;
-            counts = new_count(name, base);
-        }
+    }
 
-        if (check_match) {
-            if (g_strv_contains((const char * const *)matches, counts->name)) {
-                hwprofile_match_hit(counts, off);
-                inc_count(&counts->totals, is_write, cpu_index);
-            }
-        } else {
-            inc_count(&counts->totals, is_write, cpu_index);
-        }
+    uint32_t offset = phy_addr & 0xFF;
 
-        /* either track offsets or source of access */
-        if (source) {
-            off = (uint64_t) udata;
-        }
+    uint64_t reset_cnt;
 
-        if (pattern || source) {
-            IOLocationCounts *io_count = g_hash_table_lookup(counts->detail,
-                                                             (gpointer) off);
-            if (!io_count) {
-                io_count = new_location(counts->detail, off);
-            }
-            inc_count(&io_count->counts, is_write, cpu_index);
+    void *rst_shm_offset, *ctr_shm_offset;
+    switch (phy_addr & 0xFF)
+    {
+    case 0x00:
+        insn_count -= prof_cost;
+        toggle_icount();
+        break;
+    case 0x08:
+        break;
+    case 0x10:
+        break;
+    case 0x18:
+        rst_shm_offset = (void *)(((uint64_t *)shm_ptr) + 2);
+        memcpy(&reset_cnt, rst_shm_offset, sizeof(uint64_t));
+        if (reset_cnt == 0xdeadbeefULL)
+        {
+            insn_count = 0;
+            memset(rst_shm_offset, 0, sizeof(uint64_t));
         }
-
-        g_mutex_unlock(&lock);
+        ctr_shm_offset = (void *)(((uint64_t *)shm_ptr) + 1);
+        memcpy(ctr_shm_offset, &insn_count, sizeof(uint64_t));
+        break;
+    default:
+        break;
     }
+
+    return;
+}
+
+static void vcpu_insn_exec_before(unsigned int cpu_index, void *udata)
+{
+    insn_count += icount_on;
 }
 
 static void vcpu_tb_trans(qemu_plugin_id_t id, struct qemu_plugin_tb *tb)
@@ -245,9 +251,18 @@
     size_t n = qemu_plugin_tb_n_insns(tb);
     size_t i;
 
-    for (i = 0; i < n; i++) {
+    for (i = 0; i < n; i++)
+    {
         struct qemu_plugin_insn *insn = qemu_plugin_tb_get_insn(tb, i);
-        gpointer udata = (gpointer) (source ? qemu_plugin_insn_vaddr(insn) : 0);
+        uint64_t vaddr = qemu_plugin_insn_vaddr(insn);
+        qemu_plugin_register_vcpu_insn_exec_cb(
+            insn, vcpu_insn_exec_before, QEMU_PLUGIN_CB_NO_REGS,
+            GUINT_TO_POINTER(vaddr));
+
+        uint64_t haddr = (uint64_t)qemu_plugin_insn_haddr(insn);
+
+        //        client_send_message(primesim_socket_fd, haddr);
+        gpointer udata = (gpointer)(qemu_plugin_insn_vaddr(insn));
         qemu_plugin_register_vcpu_mem_cb(insn, vcpu_haddr,
                                          QEMU_PLUGIN_CB_NO_REGS,
                                          rw, udata);
@@ -259,44 +274,96 @@
                         int argc, char **argv)
 {
     int i;
-
-    for (i = 0; i < argc; i++) {
+    enable_log = true;
+    prof_cost = 1;
+    
+    for (i = 0; i < argc; i++)
+    {
         char *opt = argv[i];
-        if (g_strcmp0(opt, "read") == 0) {
+        if (g_strcmp0(opt, "read") == 0)
+        {
             rw = QEMU_PLUGIN_MEM_R;
-        } else if (g_strcmp0(opt, "write") == 0) {
+        }
+        else if (g_strcmp0(opt, "write") == 0)
+        {
             rw = QEMU_PLUGIN_MEM_W;
-        } else if (g_strcmp0(opt, "pattern") == 0) {
-            pattern = true;
-        } else if (g_strcmp0(opt, "source") == 0) {
-            source = true;
-        } else if (g_str_has_prefix(opt, "match")) {
+        }
+        else if (g_strcmp0(opt, "log") == 0)
+        {
+            enable_log = true;
+        }
+        else if (g_str_has_prefix(opt, "overhead") == 0)
+        {
             gchar **parts = g_strsplit(opt, "=", 2);
-            check_match = true;
-            matches = g_strsplit(parts[1], ",", -1);
+            prof_cost = atoi(parts[1]);
+            fprintf(stderr, "prof_cost %d\n", prof_cost);
             g_strfreev(parts);
-        } else {
+        }
+        else
+        {
             fprintf(stderr, "option parsing failed: %s\n", opt);
             return -1;
         }
     }
 
-    if (source && pattern) {
-        fprintf(stderr, "can only currently track either source or pattern.\n");
+    printf("qemu target is %s\n", info->target_name);
+
+    // detect system architecture
+    if (strcmp(info->target_name, "aarch64") == 0)
+    {
+        prof_arch = PROF_ARCH_AARCH64;
+        shm_path = "/icount_aarch64";
+        prof_base = 0x0f2000ULL;
+        // FIXME: change the arch
+        primesim_socket_path = "/tmp/hwprofile_aarch64";
+    }
+    else if (strcmp(info->target_name, "x86_64") == 0)
+    {
+        prof_arch = PROF_ARCH_X86_64;
+        shm_path = "/icount_x64";
+        prof_base = 0x12000000ULL;
+        primesim_socket_path = "/tmp/hwprofile_x64";
+    }
+    else
+    {
+        prof_arch = PROF_ARCH_INCOMPATIBLE;
+    }
+
+    int fd = shm_open(shm_path, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRWXU);
+    if (fd == -1)
+    {
+        printf("failed to shm_open\n");
+        return -1;
+    }
+
+    if (ftruncate(fd, shm_size) < 0)
+    {
+        printf("truncation failure\n");
         return -1;
     }
 
-    if (!info->system_emulation) {
-        fprintf(stderr, "hwprofile: plugin only useful for system emulation\n");
+    shm_ptr = mmap(NULL, shm_size, PROT_WRITE, MAP_SHARED, fd, 0);
+    if (shm_ptr == MAP_FAILED)
+    {
+        printf("mmap failed\n");
         return -1;
     }
 
-    /* Just warn about overflow */
-    if (info->system.smp_vcpus > 64 ||
-        info->system.max_vcpus > 64) {
-        fprintf(stderr, "hwprofile: can only track up to 64 CPUs\n");
+    if (!info->system_emulation)
+    {
+        fprintf(stderr, "hwprofile: plugin only useful for system emulation\n");
+        return -1;
     }
 
+    if (enable_log)
+    {
+        primesim_socket_fd = client_connect_socket(primesim_socket_path);
+        if (primesim_socket_fd == -1)
+        {
+            fprintf(stderr, "failed to connect to primesim\n");
+            return -1;
+        }
+    }
     plugin_init();
 
     qemu_plugin_register_vcpu_tb_trans_cb(id, vcpu_tb_trans);
diff -ur archive/stramash/Stramash-QEMU/contrib/plugins/Makefile qemu-stramash/contrib/plugins/Makefile
--- archive/stramash/Stramash-QEMU/contrib/plugins/Makefile	2024-05-13 16:45:02.431797223 +0100
+++ qemu-stramash/contrib/plugins/Makefile	2024-04-19 18:23:01.867100020 +0100
@@ -18,6 +18,7 @@
 NAMES += howvec
 NAMES += lockstep
 NAMES += hwprofile
+NAMES += cache-sim
 
 SONAMES := $(addsuffix .so,$(addprefix lib,$(NAMES)))
 
@@ -31,9 +32,11 @@
 all: $(SONAMES)
 
 %.o: %.c
+	@echo "Compiling: $(CC) $(CFLAGS) -c -o $@ $<"
 	$(CC) $(CFLAGS) -c -o $@ $<
 
 lib%.so: %.o
+	@echo "Linking: $(CC) -shared -Wl,-soname,$@ -o $@ $^ $(LDLIBS)"
 	$(CC) -shared -Wl,-soname,$@ -o $@ $^ $(LDLIBS)
 
 clean:
Only in qemu-stramash: docker
Only in qemu-stramash/dtc: BSD-2-Clause
Only in qemu-stramash/dtc: checks.c
Only in qemu-stramash/dtc: .cirrus.yml
Only in qemu-stramash/dtc: convert-dtsv0-lexer.l
Only in qemu-stramash/dtc: data.c
Only in qemu-stramash/dtc: Documentation
Only in qemu-stramash/dtc: dtc.c
Only in qemu-stramash/dtc: dtc.h
Only in qemu-stramash/dtc: dtc-lexer.l
Only in qemu-stramash/dtc: dtc-parser.y
Only in qemu-stramash/dtc: dtdiff
Only in qemu-stramash/dtc: .editorconfig
Only in qemu-stramash/dtc: fdtdump.c
Only in qemu-stramash/dtc: fdtget.c
Only in qemu-stramash/dtc: fdtoverlay.c
Only in qemu-stramash/dtc: fdtput.c
Only in qemu-stramash/dtc: flattree.c
Only in qemu-stramash/dtc: fstree.c
Only in qemu-stramash/dtc: .git
Only in qemu-stramash/dtc: .gitignore
Only in qemu-stramash/dtc: GPL
Only in qemu-stramash/dtc: libfdt
Only in qemu-stramash/dtc: livetree.c
Only in qemu-stramash/dtc: Makefile
Only in qemu-stramash/dtc: Makefile.convert-dtsv0
Only in qemu-stramash/dtc: Makefile.dtc
Only in qemu-stramash/dtc: Makefile.utils
Only in qemu-stramash/dtc: pylibfdt
Only in qemu-stramash/dtc: README
Only in qemu-stramash/dtc: README.license
Only in qemu-stramash/dtc: scripts
Only in qemu-stramash/dtc: srcpos.c
Only in qemu-stramash/dtc: srcpos.h
Only in qemu-stramash/dtc: tests
Only in qemu-stramash/dtc: TODO
Only in qemu-stramash/dtc: .travis.yml
Only in qemu-stramash/dtc: treesource.c
Only in qemu-stramash/dtc: util.c
Only in qemu-stramash/dtc: util.h
Only in qemu-stramash/dtc: yamltree.c
Only in qemu-stramash: .git
Only in qemu-stramash: .gitattributes
Only in qemu-stramash: .github
Only in qemu-stramash: .gitignore
Only in qemu-stramash: .gitlab-ci.d
Only in qemu-stramash: .gitlab-ci.yml
Only in qemu-stramash: .gitmodules
Only in qemu-stramash: .gitpublish
diff -ur archive/stramash/Stramash-QEMU/hw/arm/boot.c qemu-stramash/hw/arm/boot.c
--- archive/stramash/Stramash-QEMU/hw/arm/boot.c	2024-05-13 16:45:02.515798019 +0100
+++ qemu-stramash/hw/arm/boot.c	2024-04-04 01:17:08.499417240 +0100
@@ -528,6 +528,7 @@
 int arm_load_dtb(hwaddr addr, const struct arm_boot_info *binfo,
                  hwaddr addr_limit, AddressSpace *as, MachineState *ms)
 {
+    printf("\nARM LOAD DTB!!!\n");
     void *fdt = NULL;
     int size, rc, n = 0;
     uint32_t acells, scells;
@@ -599,11 +600,17 @@
         n++;
     }
     g_strfreev(node_path);
-
+    printf("\nMEMDEV: checking memory info\n");
     if (ms->numa_state != NULL && ms->numa_state->num_nodes > 0) {
+        printf("Path 1, node number is%d\n", ms->numa_state->num_nodes);
         mem_base = binfo->loader_start;
         for (i = 0; i < ms->numa_state->num_nodes; i++) {
-            mem_len = ms->numa_state->nodes[i].node_mem;
+            //NOTE: here is where we change the ram stuff
+            // the base is moved in virt.c vms->bootinfo.loader_start
+            // it's at memory base + 1/2 size
+            mem_len = (ms->numa_state->nodes[i].node_mem);
+            printf("MEMDEV: memory base is %lx, memory length is %lx\n", mem_base, mem_len);
+            //We should ignore upper half of memory
             rc = fdt_add_memory_node(fdt, acells, mem_base,
                                      scells, mem_len, i);
             if (rc < 0) {
@@ -615,8 +622,9 @@
             mem_base += mem_len;
         }
     } else {
-        rc = fdt_add_memory_node(fdt, acells, binfo->loader_start,
-                                 scells, binfo->ram_size, -1);
+        printf("MEMINFO: adding memory here\n");
+        rc = fdt_add_memory_node(fdt, acells, binfo->raw_mem_start_addr,
+                                 scells, (binfo->ram_size), -1);
         if (rc < 0) {
             fprintf(stderr, "couldn't add /memory@%"PRIx64" node\n",
                     binfo->loader_start);
diff -ur archive/stramash/Stramash-QEMU/hw/arm/Kconfig qemu-stramash/hw/arm/Kconfig
--- archive/stramash/Stramash-QEMU/hw/arm/Kconfig	2024-05-13 16:45:02.515798019 +0100
+++ qemu-stramash/hw/arm/Kconfig	2024-04-04 01:17:08.499417240 +0100
@@ -28,6 +28,9 @@
     select ACPI_HW_REDUCED
     select ACPI_NVDIMM
     select ACPI_APEI
+    select DEMO
+    select VINTC
+    select SIFIVE_GPIO
 
 config CHEETAH
     bool
diff -ur archive/stramash/Stramash-QEMU/hw/arm/virt.c qemu-stramash/hw/arm/virt.c
--- archive/stramash/Stramash-QEMU/hw/arm/virt.c	2024-05-13 16:45:02.531798171 +0100
+++ qemu-stramash/hw/arm/virt.c	2024-05-13 02:24:57.314836288 +0100
@@ -27,7 +27,7 @@
  *    information in a device binding that we aren't providing.
  * This is essentially the same approach kvmtool uses.
  */
-
+#include <unistd.h>
 #include "qemu/osdep.h"
 #include "qemu-common.h"
 #include "qemu/datadir.h"
@@ -44,6 +44,8 @@
 #include "hw/vfio/vfio-calxeda-xgmac.h"
 #include "hw/vfio/vfio-amd-xgbe.h"
 #include "hw/display/ramfb.h"
+#include "hw/misc/vintc.h"
+#include "hw/gpio/sifive_gpio.h"
 #include "net/net.h"
 #include "sysemu/device_tree.h"
 #include "sysemu/numa.h"
@@ -158,11 +160,15 @@
     /* ...repeating for a total of NUM_VIRTIO_TRANSPORTS, each of that size */
     [VIRT_PLATFORM_BUS] =       { 0x0c000000, 0x02000000 },
     [VIRT_SECURE_MEM] =         { 0x0e000000, 0x01000000 },
+    [VIRT_SHARED_MEM] =         { 0x0f000000, 0x00100000 },
+    [VIRT_VINTC] =              { 0x0f100000, 0x00000100 },
+    [VIRT_PERF_MEM] =           { 0x0f200000, 0x00100000 },
+    [VIRT_STRAMASH_GPIO]      = { 0x0f300000, 0x00100000 },
     [VIRT_PCIE_MMIO] =          { 0x10000000, 0x2eff0000 },
     [VIRT_PCIE_PIO] =           { 0x3eff0000, 0x00010000 },
     [VIRT_PCIE_ECAM] =          { 0x3f000000, 0x01000000 },
     /* Actual RAM size depends on initial RAM and device memory settings */
-    [VIRT_MEM] =                { GiB, LEGACY_RAMLIMIT_BYTES },
+    [VIRT_MEM] =                { GiB, GiB},
 };
 
 /*
@@ -190,6 +196,7 @@
     [VIRT_GPIO] = 7,
     [VIRT_SECURE_UART] = 8,
     [VIRT_ACPI_GED] = 9,
+    [VIRT_VINTC] = 10,
     [VIRT_MMIO] = 16, /* ...to 16 + NUM_VIRTIO_TRANSPORTS - 1 */
     [VIRT_GIC_V2M] = 48, /* ...to 48 + NUM_GICV2M_SPIS - 1 */
     [VIRT_SMMU] = 74,    /* ...to 74 + NUM_SMMU_IRQS - 1 */
@@ -376,13 +383,15 @@
         }
     }
 
+    printf("number of cpu is %d\n", smp_cpus + 1);
+
     qemu_fdt_add_subnode(ms->fdt, "/cpus");
     qemu_fdt_setprop_cell(ms->fdt, "/cpus", "#address-cells", addr_cells);
     qemu_fdt_setprop_cell(ms->fdt, "/cpus", "#size-cells", 0x0);
 
-    for (cpu = smp_cpus - 1; cpu >= 0; cpu--) {
+    ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(0));
+    for (cpu = smp_cpus; cpu >= 0; cpu--) {
         char *nodename = g_strdup_printf("/cpus/cpu@%d", cpu);
-        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(cpu));
         CPUState *cs = CPU(armcpu);
 
         qemu_fdt_add_subnode(ms->fdt, nodename);
@@ -408,6 +417,10 @@
                 ms->possible_cpus->cpus[cs->cpu_index].props.node_id);
         }
 
+        if (cpu == 1) {
+            qemu_fdt_setprop_string(ms->fdt, nodename, "status", "disabled");
+        }
+
         g_free(nodename);
     }
 }
@@ -622,6 +635,68 @@
     vms->msi_controller = VIRT_MSI_CTRL_GICV2M;
 }
 
+//static void create_shared_register(VirtMachineState *vms)
+//{
+//  DeviceState *dev;
+//  dev = qdev_new("demo");
+//  sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, vms->memmap[VIRT_SHARED_REG].base);
+//  sysbus_realize(SYS_BUS_DEVICE(dev), &error_fatal);
+//}
+
+static void create_virtual_intc(VirtMachineState *vms, MemoryRegion *mem)
+{
+  DeviceState  *dev;
+  MachineState *ms = MACHINE(vms);
+  hwaddr base = vms->memmap[VIRT_VINTC].base;
+  hwaddr size = vms->memmap[VIRT_VINTC].size;
+
+
+  int irq = vms->irqmap[VIRT_VINTC];
+  dev = qdev_new(TYPE_VINTC);
+  SysBusDevice *s = SYS_BUS_DEVICE(dev);
+
+  object_property_parse(OBJECT(dev), "chardev", "vintchar", &error_fatal);
+
+  sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+  memory_region_add_subregion(mem, base,
+                              sysbus_mmio_get_region(s, 0));
+//  sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, base);
+  sysbus_connect_irq(s, 0, qdev_get_gpio_in(vms->gic, irq));
+
+  const char compatible[] = "arm,vintc";
+  char *node_name;
+  node_name = g_strdup_printf("/vintc@%" PRIx64, base);
+  qemu_fdt_add_subnode(ms->fdt, node_name);
+  qemu_fdt_setprop(ms->fdt, node_name, "compatible", compatible, sizeof compatible);
+  qemu_fdt_setprop_sized_cells(ms->fdt, node_name, "reg", 2, base, 2, size);
+  qemu_fdt_setprop_cells(ms->fdt, node_name, "interrupts",GIC_FDT_IRQ_TYPE_SPI, irq, GIC_FDT_IRQ_FLAGS_LEVEL_HI);
+  g_free(node_name);
+}
+
+static void create_stramash_gpio(VirtMachineState *vms, MemoryRegion *mem)
+{
+  DeviceState  *dev;
+  MachineState *ms = MACHINE(vms);
+  hwaddr base = vms->memmap[VIRT_STRAMASH_GPIO].base;
+  hwaddr size = vms->memmap[VIRT_STRAMASH_GPIO].size;
+
+  dev = qdev_new(TYPE_SIFIVE_GPIO);
+  SysBusDevice *s = SYS_BUS_DEVICE(dev);
+
+  sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+  memory_region_add_subregion(mem, base,
+                              sysbus_mmio_get_region(s, 0));
+
+  const char compatible[] = "stramash,gpio-1.00";
+  char *node_name;
+  node_name = g_strdup_printf("/stramash_gpio@%" PRIx64, base);
+  qemu_fdt_add_subnode(ms->fdt, node_name);
+  qemu_fdt_setprop(ms->fdt, node_name, "compatible", compatible, sizeof compatible);
+  qemu_fdt_setprop_sized_cells(ms->fdt, node_name, "reg", 2, base, 2, size);
+  g_free(node_name);
+}
+
+
 static void create_gic(VirtMachineState *vms)
 {
     MachineState *ms = MACHINE(vms);
@@ -663,6 +738,8 @@
             qdev_prop_set_uint32(vms->gic, "redist-region-count[1]",
                 MIN(smp_cpus - redist0_count, redist1_capacity));
         }
+        object_property_parse(OBJECT(vms->gic), "arm-chr", "arm_chr", &error_fatal);
+        printf("Finished parsing\n");
     } else {
         if (!kvm_irqchip_in_kernel()) {
             qdev_prop_set_bit(vms->gic, "has-virtualization-extensions",
@@ -828,6 +905,7 @@
     }
 }
 
+
 static void create_gpio_keys(char *fdt, DeviceState *pl061_dev,
                              uint32_t phandle)
 {
@@ -1469,6 +1547,39 @@
     memory_region_add_subregion(tag_sysmem, base / 32, tagram);
 }
 
+static void create_perf_ram(MemoryRegion *perf_sysmem,
+        VirtMachineState *vms,
+        const char *name)
+{
+  hwaddr base = vms->memmap[VIRT_PERF_MEM].base;
+  hwaddr size = vms->memmap[VIRT_PERF_MEM].size;
+
+    MemoryRegion *perf_mem = g_new(MemoryRegion, 1);
+
+    char filename[256];
+    int pid = getpid();
+    sprintf(filename, "/dev/shm/icount_aarch64_%d", pid);
+
+    memory_region_init_ram_from_file(perf_mem, NULL, name, size, 0, RAM_SHARED, filename, false , &error_fatal);
+    memory_region_add_subregion(perf_sysmem, base  , perf_mem);
+}
+
+static void create_shared_ram(MemoryRegion *shared_sysmem,
+                              VirtMachineState *vms,
+                           const char *name)
+{
+  hwaddr base = vms->memmap[VIRT_SHARED_MEM].base;
+  hwaddr size = vms->memmap[VIRT_SHARED_MEM].size;
+  MemoryRegion *shared_ram = g_new(MemoryRegion, 1);
+  
+  char filename[256];
+  int pid = getpid();
+  sprintf(filename, "/dev/shm/share_%d", pid);
+
+  memory_region_init_ram_from_file(shared_ram, NULL, name, size, 0, RAM_SHARED, filename, false, &error_fatal);
+  memory_region_add_subregion(shared_sysmem, base, shared_ram);
+}
+
 static void create_secure_ram(VirtMachineState *vms,
                               MemoryRegion *secure_sysmem,
                               MemoryRegion *secure_tag_sysmem)
@@ -1615,6 +1726,7 @@
      * is aligned on 1GiB. We never put the high IO region below 256GiB
      * so that if maxram_size is < 255GiB we keep the legacy memory map.
      * The device region size assumes 1GiB page max alignment per slot.
+     * NOTE: don't care about this part as it's above device virtual memory
      */
     device_memory_base =
         ROUND_UP(vms->memmap[VIRT_MEM].base + ms->ram_size, GiB);
@@ -1640,10 +1752,13 @@
     }
     vms->highest_gpa = base - 1;
     if (device_memory_size > 0) {
+        g_assert(0);
+        device_memory_size = device_memory_size >> 2;
+        printf("DEVMEM: device memory size is %lx, device_memory_base is %lx\n", device_memory_size, device_memory_base);
         ms->device_memory = g_malloc0(sizeof(*ms->device_memory));
         ms->device_memory->base = device_memory_base;
-        memory_region_init(&ms->device_memory->mr, OBJECT(vms),
-                           "device-memory", device_memory_size);
+        memory_region_init_ram_from_file(&ms->device_memory->mr, OBJECT(vms),
+                           "ddr-share", device_memory_size, 0, RAM_SHARED, "/dev/shm/devmem", false, &error_fatal);
     }
 }
 
@@ -1652,6 +1767,7 @@
  * according to the gic-version property
  *
  * Default GIC type is v2
+ * bump gic version to v3 for better documentation and support
  */
 static void finalize_gic_version(VirtMachineState *vms)
 {
@@ -1669,7 +1785,7 @@
                 return;
             case VIRT_GIC_VERSION_MAX:
             case VIRT_GIC_VERSION_NOSEL:
-                vms->gic_version = VIRT_GIC_VERSION_2;
+                vms->gic_version = VIRT_GIC_VERSION_3;
                 return;
             case VIRT_GIC_VERSION_2:
                 return;
@@ -1732,7 +1848,7 @@
     /* TCG mode */
     switch (vms->gic_version) {
     case VIRT_GIC_VERSION_NOSEL:
-        vms->gic_version = VIRT_GIC_VERSION_2;
+        vms->gic_version = VIRT_GIC_VERSION_3;
         break;
     case VIRT_GIC_VERSION_MAX:
         vms->gic_version = VIRT_GIC_VERSION_3;
@@ -1865,6 +1981,8 @@
         memory_region_add_subregion_overlap(secure_sysmem, 0, sysmem, -1);
     }
 
+
+
     firmware_loaded = virt_firmware_init(vms, sysmem,
                                          secure_sysmem ?: sysmem);
 
@@ -1982,12 +2100,19 @@
 
         object_property_set_link(cpuobj, "memory", OBJECT(sysmem),
                                  &error_abort);
+
         if (vms->secure) {
             object_property_set_link(cpuobj, "secure-memory",
                                      OBJECT(secure_sysmem), &error_abort);
         }
 
+        create_shared_ram(sysmem, vms, "shared-memory");
+
+        create_perf_ram(sysmem,vms, "perf-memory");
+
+
         if (vms->mte) {
+
             /* Create the memory region only once, but link to all cpus. */
             if (!tag_sysmem) {
                 /*
@@ -2037,6 +2162,7 @@
                                     &machine->device_memory->mr);
     }
 
+
     virt_flash_fdt(vms, sysmem, secure_sysmem ?: sysmem);
 
     create_gic(vms);
@@ -2057,6 +2183,12 @@
                        machine->ram_size, "mach-virt.tag");
     }
 
+//    create_shared_register(vms);
+
+    //create_virtual_intc(vms, sysmem);
+
+    create_stramash_gpio(vms, sysmem);
+
     vms->highmem_ecam &= vms->highmem && (!firmware_loaded || aarch64);
 
     create_rtc(vms);
@@ -2100,10 +2232,12 @@
                                vms->fw_cfg, OBJECT(vms));
     }
 
-    vms->bootinfo.ram_size = machine->ram_size;
+    vms->bootinfo.ram_size = machine->ram_size - 2 * GiB;
     vms->bootinfo.nb_cpus = smp_cpus;
     vms->bootinfo.board_id = -1;
-    vms->bootinfo.loader_start = vms->memmap[VIRT_MEM].base;
+    vms->bootinfo.loader_start = vms->memmap[VIRT_MEM].base + 1.5 * GiB;
+    vms->bootinfo.raw_mem_start_addr = vms->memmap[VIRT_MEM].base + 1.5 * GiB;
+    printf("\nMEMDEV: memory base is %lx, loader start is %lx\n", vms->memmap[VIRT_MEM].base, vms->bootinfo.loader_start);
     vms->bootinfo.get_dtb = machvirt_dtb;
     vms->bootinfo.skip_dtb_autoload = true;
     vms->bootinfo.firmware_loaded = firmware_loaded;
@@ -2717,7 +2851,7 @@
         vms->its = false;
     } else {
         /* Default allows ITS instantiation */
-        vms->its = true;
+        vms->its = false;
     }
 
     /* Default disallows iommu instantiation */
diff -ur archive/stramash/Stramash-QEMU/hw/char/Kconfig qemu-stramash/hw/char/Kconfig
--- archive/stramash/Stramash-QEMU/hw/char/Kconfig	2024-05-13 16:45:02.543798285 +0100
+++ qemu-stramash/hw/char/Kconfig	2024-04-04 01:17:08.519417425 +0100
@@ -67,3 +67,6 @@
 
 config GOLDFISH_TTY
     bool
+
+config VIRTUAL_INTC
+    bool
diff -ur archive/stramash/Stramash-QEMU/hw/core/register.c qemu-stramash/hw/core/register.c
--- archive/stramash/Stramash-QEMU/hw/core/register.c	2024-05-13 16:45:02.555798398 +0100
+++ qemu-stramash/hw/core/register.c	2024-04-04 01:17:08.527417499 +0100
@@ -34,9 +34,6 @@
     case 4:
         *(uint32_t *)reg->data = val;
         break;
-    case 8:
-        *(uint64_t *)reg->data = val;
-        break;
     default:
         g_assert_not_reached();
     }
@@ -51,8 +48,6 @@
         return *(uint16_t *)reg->data;
     case 4:
         return *(uint32_t *)reg->data;
-    case 8:
-        return *(uint64_t *)reg->data;
     default:
         g_assert_not_reached();
     }
@@ -249,7 +244,22 @@
     int data_size = data_size_bits >> 3;
     int i;
 
-    r_array->r = g_new0(RegisterInfo *, num);
+    // here goes the shared memory allocation stuff
+    int reg_fd = shm_open("/test", O_RDWR|O_CREAT,S_IRUSR | S_IWUSR);
+    if (reg_fd == -1) {
+      perror("open");
+      g_assert(0);
+    }
+  size_t reg_len = sizeof(RegisterInfoArray)*num;
+  if (ftruncate(reg_fd, reg_len) == -1) {
+    perror("ftruncate");
+    g_assert(0);
+  }
+    void *reg_addr = mmap(NULL, sizeof(RegisterInfoArray)*num, PROT_READ|PROT_WRITE, MAP_SHARED, reg_fd, 0);
+
+    // TODO: currently the problem is that too much information is shared in the register
+    // we should dial it down a lot
+    r_array->r = reg_addr;
     r_array->num_elements = num;
     r_array->debug = debug_enabled;
     r_array->prefix = device_prefix;
@@ -267,6 +277,7 @@
         r->access = &rae[i];
         r->opaque = owner;
 
+        // this is the actual problem
         r_array->r[i] = r;
     }
 
@@ -302,9 +313,9 @@
 
 void register_finalize_block(RegisterInfoArray *r_array)
 {
-    object_unparent(OBJECT(&r_array->mem));
-    g_free(r_array->r);
-    g_free(r_array);
+    //object_unparent(OBJECT(&r_array->mem));
+    //g_free(r_array->r);
+    //g_free(r_array);
 }
 
 static void register_class_init(ObjectClass *oc, void *data)
Only in qemu-stramash/hw: demo
diff -ur archive/stramash/Stramash-QEMU/hw/gpio/sifive_gpio.c qemu-stramash/hw/gpio/sifive_gpio.c
--- archive/stramash/Stramash-QEMU/hw/gpio/sifive_gpio.c	2024-05-13 16:45:02.575798588 +0100
+++ qemu-stramash/hw/gpio/sifive_gpio.c	2024-04-04 01:17:08.543417647 +0100
@@ -13,28 +13,11 @@
 
 #include "qemu/osdep.h"
 #include "qemu/log.h"
-#include "hw/irq.h"
 #include "hw/qdev-properties.h"
 #include "hw/gpio/sifive_gpio.h"
 #include "migration/vmstate.h"
 #include "trace.h"
 
-static void update_output_irq(SIFIVEGPIOState *s)
-{
-    uint32_t pending;
-    uint32_t pin;
-
-    pending = s->high_ip & s->high_ie;
-    pending |= s->low_ip & s->low_ie;
-    pending |= s->rise_ip & s->rise_ie;
-    pending |= s->fall_ip & s->fall_ie;
-
-    for (int i = 0; i < s->ngpio; i++) {
-        pin = 1 << i;
-        qemu_set_irq(s->irq[i], (pending & pin) != 0);
-        trace_sifive_gpio_update_output_irq(i, (pending & pin) != 0);
-    }
-}
 
 static void update_state(SIFIVEGPIOState *s)
 {
@@ -76,10 +59,7 @@
             actual_value = pull;
         }
 
-        if (output_en) {
-            qemu_set_irq(s->output[i], actual_value);
-        }
-
+        
         /* Input value */
         ival = input_en && actual_value;
 
@@ -97,9 +77,8 @@
         s->fall_ip = deposit32(s->fall_ip, i, 1, fall_ip);
 
         /* Update value */
-        s->value = deposit32(s->value, i, 1, ival);
+        // s->value = deposit32(s->value, i, 1, ival);
     }
-    update_output_irq(s);
 }
 
 static uint64_t sifive_gpio_read(void *opaque, hwaddr offset, unsigned int size)
@@ -196,6 +175,10 @@
 
     switch (offset) {
 
+    case SIFIVE_GPIO_REG_VALUE:
+        s->value = value;
+        break;
+
     case SIFIVE_GPIO_REG_INPUT_EN:
         s->input_en = value;
         break;
@@ -293,6 +276,7 @@
     if (value >= 0) {
         s->in = deposit32(s->in, line, 1, value != 0);
     }
+    // s->value = 0xdeadbeef;
 
     update_state(s);
 }
@@ -363,10 +347,7 @@
 
     sysbus_init_mmio(SYS_BUS_DEVICE(dev), &s->mmio);
 
-    for (int i = 0; i < s->ngpio; i++) {
-        sysbus_init_irq(SYS_BUS_DEVICE(dev), &s->irq[i]);
-    }
-
+    
     qdev_init_gpio_in(DEVICE(s), sifive_gpio_set, s->ngpio);
     qdev_init_gpio_out(DEVICE(s), s->output, s->ngpio);
 }
diff -ur archive/stramash/Stramash-QEMU/hw/i386/Kconfig qemu-stramash/hw/i386/Kconfig
--- archive/stramash/Stramash-QEMU/hw/i386/Kconfig	2024-05-13 16:45:02.579798626 +0100
+++ qemu-stramash/hw/i386/Kconfig	2024-04-04 01:17:08.547417685 +0100
@@ -36,6 +36,8 @@
     select ACPI_VMGENID
     select VIRTIO_PMEM_SUPPORTED
     select VIRTIO_MEM_SUPPORTED
+    select VINTC
+    select SIFIVE_GPIO
 
 config PC_PCI
     bool
diff -ur archive/stramash/Stramash-QEMU/hw/i386/microvm.c qemu-stramash/hw/i386/microvm.c
--- archive/stramash/Stramash-QEMU/hw/i386/microvm.c	2024-05-13 16:45:02.583798664 +0100
+++ qemu-stramash/hw/i386/microvm.c	2024-04-04 01:17:08.547417685 +0100
@@ -317,6 +317,18 @@
         e820_add_entry(0x100000000ULL, x86ms->above_4g_mem_size, E820_RAM);
     }
 
+    MemoryRegion *share_mem = g_new(MemoryRegion, 1);
+
+    memory_region_init_ram_from_file(share_mem, NULL,
+                                   "microvm.shared-ram",
+                                     0x100000, 0,
+                                   RAM_SHARED, "/dev/shm/share",
+                                   false,
+                                   &error_fatal);
+    memory_region_add_subregion(system_memory,
+                              0x100000, share_mem);
+    //e820_add_entry(0x100000,0x1000000, E820_RAM);
+
     fw_cfg = fw_cfg_init_io_dma(FW_CFG_IO_BASE, FW_CFG_IO_BASE + 4,
                                 &address_space_memory);
 
diff -ur archive/stramash/Stramash-QEMU/hw/i386/pc.c qemu-stramash/hw/i386/pc.c
--- archive/stramash/Stramash-QEMU/hw/i386/pc.c	2024-05-13 16:45:02.587798702 +0100
+++ qemu-stramash/hw/i386/pc.c	2024-05-13 02:11:38.459102955 +0100
@@ -21,7 +21,7 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
-
+#include <unistd.h>
 #include "qemu/osdep.h"
 #include "qemu/units.h"
 #include "hw/i386/x86.h"
@@ -51,6 +51,7 @@
 #include "hw/input/i8042.h"
 #include "hw/irq.h"
 #include "hw/audio/pcspk.h"
+#include "hw/misc/vintc.h"
 #include "hw/pci/msi.h"
 #include "hw/sysbus.h"
 #include "sysemu/sysemu.h"
@@ -883,8 +884,11 @@
     memory_region_init_alias(ram_below_4g, NULL, "ram-below-4g", machine->ram,
                              0, x86ms->below_4g_mem_size);
     memory_region_add_subregion(system_memory, 0, ram_below_4g);
-    e820_add_entry(0, x86ms->below_4g_mem_size, E820_RAM);
+    printf("\nMEMINFO: real world memory size is 0x%lx\n", x86ms->below_4g_mem_size);
+    e820_add_entry(0, x86ms->below_4g_mem_size / 2, E820_RAM);
     if (x86ms->above_4g_mem_size > 0) {
+        printf("Ram size > 4G for x86, aborting");
+//        g_assert(0);
         ram_above_4g = g_malloc(sizeof(*ram_above_4g));
         memory_region_init_alias(ram_above_4g, NULL, "ram-above-4g",
                                  machine->ram,
@@ -895,7 +899,33 @@
         e820_add_entry(0x100000000ULL, x86ms->above_4g_mem_size, E820_RAM);
     }
 
-    if (!pcmc->has_reserved_memory &&
+  MemoryRegion *share_mem = g_new(MemoryRegion, 1);
+  char filename1[256];
+  int pid1 = getpid();
+  sprintf(filename1, "/dev/shm/share_%d", pid1);
+
+  memory_region_init_ram_from_file(share_mem, NULL,
+                                   "pc.shared-ram",
+                                   0x100000, 0,
+                                   RAM_SHARED, filename1,
+                                   0,
+                                   &error_fatal);
+  memory_region_add_subregion(system_memory,
+                              0x1000000000ULL, share_mem);
+
+  MemoryRegion *benchmark_mem = g_new(MemoryRegion, 1);
+
+  char filename[256];
+  int pid = getpid();
+  sprintf(filename, "/dev/shm/icount_x64_%d", pid);
+
+  memory_region_init_ram_from_file(benchmark_mem, NULL, "pc.benchmark_mem", 0x100000, 0, RAM_SHARED, filename, false ,&error_fatal);
+  memory_region_add_subregion(system_memory, 0x1200000000ULL, benchmark_mem);
+
+  //FIXME: add this information to e820
+  //e820_add_entry(0x1000000000ULL, 0x1000000ULL, E820_RAM);
+
+  if (!pcmc->has_reserved_memory &&
         (machine->ram_slots ||
          (machine->maxram_size > machine->ram_size))) {
 
@@ -1151,7 +1181,23 @@
         pit_alt_irq = qdev_get_gpio_in(hpet, HPET_LEGACY_PIT_INT);
         rtc_irq = qdev_get_gpio_in(hpet, HPET_LEGACY_RTC_INT);
     }
-    *rtc_state = mc146818_rtc_init(isa_bus, 2000, rtc_irq);
+
+    DeviceState *vint_dev;
+    hwaddr base = 0x1100000000;
+    //FIX: correct irq number
+    int irq = 0;
+    vint_dev = qdev_new(TYPE_VINTC);
+    SysBusDevice *vint_sysbus = SYS_BUS_DEVICE(vint_dev);
+
+    object_property_parse(OBJECT(vint_dev), "chardev", "vintchar", &error_fatal);
+
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(vint_dev), &error_fatal);
+//  memory_region_add_subregion(mem, base,
+//                              sysbus_mmio_get_region(s, 0));
+    sysbus_mmio_map(SYS_BUS_DEVICE(vint_dev), 0, base);
+    sysbus_connect_irq(vint_sysbus, 0, gsi[irq]);
+
+  *rtc_state = mc146818_rtc_init(isa_bus, 2000, rtc_irq);
 
     qemu_register_boot_set(pc_boot_set, *rtc_state);
 
@@ -1192,6 +1238,7 @@
     rom_reset_order_override();
 }
 
+//TODO: do I need to change i8259?
 void pc_i8259_create(ISABus *isa_bus, qemu_irq *i8259_irqs)
 {
     qemu_irq *i8259;
diff -ur archive/stramash/Stramash-QEMU/hw/i386/pc_piix.c qemu-stramash/hw/i386/pc_piix.c
--- archive/stramash/Stramash-QEMU/hw/i386/pc_piix.c	2024-05-13 16:45:02.587798702 +0100
+++ qemu-stramash/hw/i386/pc_piix.c	2024-04-04 01:17:08.551417721 +0100
@@ -73,7 +73,9 @@
 static const int ide_irq[MAX_IDE_BUS] = { 14, 15 };
 #endif
 
-/* PC hardware initialisation */
+/* PC hardware initialisation
+ * this function gets called for -M pc
+ * */
 static void pc_init1(MachineState *machine,
                      const char *host_type, const char *pci_type)
 {
diff -ur archive/stramash/Stramash-QEMU/hw/intc/apic.c qemu-stramash/hw/intc/apic.c
--- archive/stramash/Stramash-QEMU/hw/intc/apic.c	2024-05-13 16:45:02.595798777 +0100
+++ qemu-stramash/hw/intc/apic.c	2024-04-04 01:17:08.555417758 +0100
@@ -30,6 +30,9 @@
 #include "hw/i386/apic-msidef.h"
 #include "qapi/error.h"
 #include "qom/object.h"
+#include "hw/qdev-properties-system.h"
+#include "hw/qdev-properties.h"
+#include "qemu/cutils.h"
 
 #define MAX_APICS 255
 #define MAX_APIC_WORDS 8
@@ -50,6 +53,204 @@
 static void apic_get_delivery_bitmask(uint32_t *deliver_bitmask,
                                       uint8_t dest, uint8_t dest_mode);
 
+static void apic_interrupt_cb(void *opaque)
+{
+    APICCommonState *apic = (APICCommonState *) opaque;
+    
+    uint16_t posn = apic->vm_id;
+    
+    event_notifier_test_and_clear(&apic->eventfd[posn]);
+    
+    apic_set_irq(apic, 0xdd, 0);
+    //TODO: add stuff here
+    int send_msg = 0xdead;
+    write(apic->ipi_fifo_fd, &send_msg, sizeof(send_msg)); 
+
+    CPU(apic->cpu)->pending_ipi = true;
+}
+
+static void apic_process_msg_disconnect(APICCommonState *s, uint16_t posn, Error **errp)
+{
+    event_notifier_cleanup(&s->eventfd[posn]);
+}
+
+static void apic_process_msg_connect(APICCommonState *s, uint16_t posn, int fd,
+                                Error **errp)
+{
+  /*
+   * The N-th connect message for this peer comes with the file
+   * descriptor for vector N-1.  Count messages to find the vector.
+   */
+
+  event_notifier_init_fd(&s->eventfd[posn], fd);
+  fcntl_setfl(fd, O_NONBLOCK);
+
+  if (posn == s->vm_id) {
+      APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
+      int eventfd = event_notifier_get_fd(&s->eventfd[posn]);
+      //TODO: set opaque as null, pass arguments as we see fit
+      qemu_set_fd_handler(eventfd, info->interrupt_cb, NULL, s);
+  }
+}
+
+static void process_msg(APICCommonState *s, int64_t msg, int fd, Error **errp)
+{
+
+  if (msg == -1) {
+    //TODO: disable shm in server in the future
+    return;
+  }
+
+  if (fd >= 0) {
+    apic_process_msg_connect(s, msg, fd, errp);
+  } else {
+    apic_process_msg_disconnect(s, msg, errp);
+  }
+}
+
+
+
+static int64_t apic_recv_msg(APICCommonState *s, int *pfd, Error **errp)
+{
+  int64_t msg;
+  int n, ret;
+
+  n = 0;
+  do {
+    ret = qemu_chr_fe_read_all(&s->chr, (uint8_t *)&msg + n,
+                               sizeof(msg) - n);
+    if (ret < 0) {
+      if (ret == -EINTR) {
+        continue;
+      }
+      error_setg_errno(errp, -ret, "read from server failed");
+      return INT64_MIN;
+    }
+    n += ret;
+  } while (n < sizeof(msg));
+
+  *pfd = qemu_chr_fe_get_msgfd(&s->chr);
+  return le64_to_cpu(msg);
+}
+
+static void apic_read(void *opaque, const uint8_t *buf, int size)
+{
+  APICCommonState *s = opaque;
+  Error *err = NULL;
+  int fd;
+  int64_t msg;
+
+  assert(size >= 0 && s->msg_buffered_bytes + size <= sizeof(s->msg_buf));
+  memcpy((unsigned char *)&s->msg_buf + s->msg_buffered_bytes, buf, size);
+  s->msg_buffered_bytes += size;
+  if (s->msg_buffered_bytes < sizeof(s->msg_buf)) {
+    return;
+  }
+  msg = le64_to_cpu(s->msg_buf);
+
+
+  s->msg_buffered_bytes = 0;
+
+  fd = qemu_chr_fe_get_msgfd(&s->chr);
+
+  process_msg(s, msg, fd, &err);
+  if (err) {
+    error_report_err(err);
+  }
+}
+
+static int apic_can_receive(void *opaque)
+{
+  APICCommonState *s = opaque;
+
+  assert(s->msg_buffered_bytes < sizeof(s->msg_buf));
+  return sizeof(s->msg_buf) - s->msg_buffered_bytes;
+}
+
+static void apic_send_interrupt(void *opaque, int target)
+{
+    APICCommonState *s = opaque;
+    if (target > 1) {
+        printf("target is too large\n");
+        return;
+    }
+    event_notifier_set(&s->eventfd[target]);
+    int recv_buf;   
+    read(s->ipi_fifo_fd, &recv_buf, sizeof(recv_buf));
+    if (recv_buf != 0xbeef) {
+        printf("Data received is %x instead of 0xbeef for x86!\n", recv_buf);
+    }
+
+}
+
+
+static void apic_recv_setup(APICCommonState *s, Error **errp)
+{
+  Error *err = NULL;
+  int64_t msg;
+  int fd;
+
+  msg = apic_recv_msg(s, &fd, &err);
+  if (err) {
+    error_propagate(errp, err);
+    return;
+  }
+  if (msg != 0x0) {
+    error_setg(errp, "server sent version %" PRId64 ", expecting %d",
+               msg, 0x0);
+    return;
+  }
+
+  if (fd != -1) {
+    error_setg(errp, "server sent invalid version message");
+    return;
+  }
+
+  /*
+   * vintc-server sends the remaining initial messages in a fixed
+   * order, but the device has always accepted them in any order.
+   * Stay as compatible as practical, just in case people use
+   * servers that behave differently.
+   */
+
+  /*
+   * vintc_device_spec.txt has always required the ID message
+   * right here, and vintc-server has always complied.  However,
+   * older versions of the device accepted it out of order, but
+   * broke when an interrupt setup message arrived before it.
+   */
+  msg = apic_recv_msg(s, &fd, &err);
+  if (err) {
+    error_propagate(errp, err);
+    return;
+  }
+  //if (fd != -1 || msg < 0 || msg > 1) {
+  //  error_setg(errp, "server sent invalid ID message");
+  //  return;
+  //}
+
+  s->vm_id = msg;
+
+  /*
+   * Receive more messages until we got shared memory.
+   */
+  do {
+    msg = apic_recv_msg(s, &fd, &err);
+    if (err) {
+      error_propagate(errp, err);
+      return;
+    }
+    process_msg(s, msg, fd, &err);
+    if (err) {
+      error_propagate(errp, err);
+      return;
+    }
+  } while (msg != -1);
+}
+
+
+
+
 /* Find first bit starting from msb */
 static int apic_fls_bit(uint32_t value)
 {
@@ -460,6 +661,8 @@
     int i;
 
     if (dest_mode == 0) {
+        // printf("apic operating in physical mode\n");
+        // TODO: this is the physical mode. QEMU *never* operates here
         if (dest == 0xff) {
             memset(deliver_bitmask, 0xff, MAX_APIC_WORDS * sizeof(uint32_t));
         } else {
@@ -469,15 +672,27 @@
                 apic_set_bit(deliver_bitmask, idx);
         }
     } else {
+        //TODO: this is the logical mode
         /* XXX: cluster mode */
+        // printf("apic operating in cluster mode\n");
         memset(deliver_bitmask, 0x00, MAX_APIC_WORDS * sizeof(uint32_t));
         for(i = 0; i < MAX_APICS; i++) {
             apic_iter = local_apics[i];
             if (apic_iter) {
                 if (apic_iter->dest_mode == 0xf) {
+                    //TODO: this dest_mode differs between cluster and flat
+                    //this is flat
                     if (dest & apic_iter->log_dest)
+                        // printf("apic operating in logical flat mode, dest is %x\n", dest);
                         apic_set_bit(deliver_bitmask, i);
+                    if (dest == (1 << 1)) {
+                        //TODO: send logic is correct, receive logic isn't
+                        APICCommonClass *info = APIC_COMMON_GET_CLASS(apic_iter);
+                        info->send_interrupt(apic_iter, (apic_iter->vm_id == 1) ? 0 : 1);
+                    }
                 } else if (apic_iter->dest_mode == 0x0) {
+                    // TODO: qemu never enters here: this is cluster mode
+                    // printf("apic operating in logical cluster mode\n");
                     if ((dest & 0xf0) == (apic_iter->log_dest & 0xf0) &&
                         (dest & apic_iter->log_dest & 0x0f)) {
                         apic_set_bit(deliver_bitmask, i);
@@ -508,6 +723,7 @@
     s->wait_for_sipi = 0;
 }
 
+//TODO: this is where apic ipi gets invoked
 static void apic_deliver(DeviceState *dev, uint8_t dest, uint8_t dest_mode,
                          uint8_t delivery_mode, uint8_t vector_num,
                          uint8_t trigger_mode)
@@ -519,6 +735,7 @@
 
     switch (dest_shorthand) {
     case 0:
+        //TODO: should be here, where dest shorthand represends the `dest'
         apic_get_delivery_bitmask(deliver_bitmask, dest, dest_mode);
         break;
     case 1:
@@ -876,6 +1093,10 @@
         return;
     }
 
+    // result is 0.
+    // There is indeed only a single apic when there's only one core
+    // printf("apic id is %d\n", s->id);
+
     if (kvm_enabled()) {
         warn_report("Userspace local APIC is deprecated for KVM.");
         warn_report("Do not use kernel-irqchip except for the -M isapc machine type.");
@@ -884,10 +1105,42 @@
     memory_region_init_io(&s->io_memory, OBJECT(s), &apic_io_ops, s, "apic-msi",
                           APIC_SPACE_SIZE);
 
+    //TODO: check me
     s->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, apic_timer, s);
     local_apics[s->id] = s;
 
     msi_nonbroken = true;
+
+    APICCommonClass *agcc = APIC_COMMON_GET_CLASS(s);
+    
+    if (!qemu_chr_fe_backend_connected(&s->chr)) {
+        error_setg(errp, "apic requires a backend connected to a character device");
+        return;
+    }
+
+
+    Chardev *chr = qemu_chr_fe_get_driver(&s->chr);
+    if (!chr) {
+        error_setg(errp, "apic requires a backend connected to a character device");
+        return;
+    }
+
+
+    Error *err = NULL;
+    agcc->recv_setup(s, &err);
+
+    if (err) {
+        error_propagate(errp, err);
+        return;
+    }
+
+    qemu_chr_fe_set_handlers(&s->chr, agcc->can_read_cb,
+                             agcc->read_cb, NULL, NULL, s, NULL, true);
+    
+    s->ipi_fifo_path = "/tmp/cross_arch_ipi_fifo";
+    mkfifo(s->ipi_fifo_path, 0666);
+    s->ipi_fifo_fd = open(s->ipi_fifo_path, O_RDWR);
+   
 }
 
 static void apic_unrealize(DeviceState *dev)
@@ -898,12 +1151,19 @@
     local_apics[s->id] = NULL;
 }
 
+static Property apic_properties[] = {
+    DEFINE_PROP_CHR("x86-chr", APICCommonState, chr),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
 static void apic_class_init(ObjectClass *klass, void *data)
 {
+    DeviceClass *dc = DEVICE_CLASS(klass);
     APICCommonClass *k = APIC_COMMON_CLASS(klass);
 
     k->realize = apic_realize;
     k->unrealize = apic_unrealize;
+    device_class_set_props(dc, apic_properties);
     k->set_base = apic_set_base;
     k->set_tpr = apic_set_tpr;
     k->get_tpr = apic_get_tpr;
@@ -912,6 +1172,16 @@
     k->pre_save = apic_pre_save;
     k->post_load = apic_post_load;
     k->send_msi = apic_send_msi;
+    
+    k->process_msg_disconnect = apic_process_msg_disconnect;
+    k->process_msg_connect = apic_process_msg_connect;
+    k->process_msg = process_msg;
+    k->recv_msg = apic_recv_msg;
+    k->read_cb = apic_read;
+    k->can_read_cb = apic_can_receive;
+    k->send_interrupt = apic_send_interrupt;
+    k->recv_setup = apic_recv_setup;
+    k->interrupt_cb = apic_interrupt_cb;
 }
 
 static const TypeInfo apic_info = {
diff -ur archive/stramash/Stramash-QEMU/hw/intc/arm_gicv3.c qemu-stramash/hw/intc/arm_gicv3.c
--- archive/stramash/Stramash-QEMU/hw/intc/arm_gicv3.c	2024-05-13 16:45:02.599798816 +0100
+++ qemu-stramash/hw/intc/arm_gicv3.c	2024-04-04 01:17:08.559417796 +0100
@@ -14,14 +14,29 @@
  * the device class itself and the functions for handling interrupts
  * coming in and going out live.
  */
-
 #include "qemu/osdep.h"
 #include "qapi/error.h"
 #include "qemu/module.h"
 #include "hw/sysbus.h"
 #include "hw/intc/arm_gicv3.h"
+#include "hw/core/cpu.h"
 #include "gicv3_internal.h"
 
+static void arm_gicv3_interrupt_cb(void *opaque)
+{
+    GICv3State *s = (GICv3State *)opaque;
+    int posn = s->vm_id;
+    event_notifier_test_and_clear(&s->eventfd[posn]);
+    GICv3CPUState *cs = &s->cpu[0];
+    gicv3_redist_send_sgi(cs, GICV3_G1NS, 7, 1);
+    
+    int send_msg = 0xbeef;
+    // write to named pipe to acknowledge
+    write(s->ipi_fifo_fd, &send_msg, sizeof(send_msg));
+    (s->cpu[0]).cpu->pending_ipi = true;
+}
+
+
 static bool irqbetter(GICv3CPUState *cs, int irq, uint8_t prio)
 {
     /* Return true if this IRQ at this priority should take
@@ -190,6 +205,8 @@
 {
     gicv3_redist_update_noirqset(cs);
     gicv3_cpuif_update(cs);
+    //TODO: gicv3_redist_send_sgi();
+    //TODO: call some other function?
 }
 
 /* Update the GIC status after state in the distributor has
@@ -397,6 +414,7 @@
 
     agcc->post_load = arm_gicv3_post_load;
     device_class_set_parent_realize(dc, arm_gic_realize, &agc->parent_realize);
+    agcc->interrupt_cb = arm_gicv3_interrupt_cb;
 }
 
 static const TypeInfo arm_gicv3_info = {
diff -ur archive/stramash/Stramash-QEMU/hw/intc/arm_gicv3_common.c qemu-stramash/hw/intc/arm_gicv3_common.c
--- archive/stramash/Stramash-QEMU/hw/intc/arm_gicv3_common.c	2024-05-13 16:45:02.599798816 +0100
+++ qemu-stramash/hw/intc/arm_gicv3_common.c	2024-04-04 01:17:08.559417796 +0100
@@ -25,6 +25,7 @@
 #include "qapi/error.h"
 #include "qemu/module.h"
 #include "hw/core/cpu.h"
+#include "hw/qdev-properties-system.h"
 #include "hw/intc/arm_gicv3_common.h"
 #include "hw/qdev-properties.h"
 #include "migration/vmstate.h"
@@ -32,6 +33,189 @@
 #include "hw/arm/linux-boot-if.h"
 #include "sysemu/kvm.h"
 
+static void gicv3_process_msg_disconnect(GICv3State *s, uint16_t posn, Error **errp)
+{
+    event_notifier_cleanup(&s->eventfd[posn]);
+}
+
+static void gicv3_process_msg_connect(GICv3State *s, uint16_t posn, int fd,
+                                Error **errp)
+{
+  /*
+   * The N-th connect message for this peer comes with the file
+   * descriptor for vector N-1.  Count messages to find the vector.
+   */
+  ARMGICv3CommonClass *agcc = ARM_GICV3_COMMON_GET_CLASS(s);
+  
+  event_notifier_init_fd(&s->eventfd[posn], fd);
+  fcntl_setfl(fd, O_NONBLOCK);
+
+  if (posn == s->vm_id) {
+      int eventfd = event_notifier_get_fd(&s->eventfd[posn]);
+      //TODO: set opaque as null, pass arguments as we see fit
+      qemu_set_fd_handler(eventfd, agcc->interrupt_cb, NULL, s);
+  }
+
+}
+
+static void process_msg(GICv3State *s, int64_t msg, int fd, Error **errp)
+{
+
+  if (msg == -1) {
+    //TODO: disable shm in server in the future
+    return;
+  }
+
+  if (fd >= 0) {
+    gicv3_process_msg_connect(s, msg, fd, errp);
+  } else {
+    gicv3_process_msg_disconnect(s, msg, errp);
+  }
+}
+
+
+
+static int64_t gicv3_recv_msg(GICv3State *s, int *pfd, Error **errp)
+{
+  int64_t msg;
+  int n, ret;
+
+  n = 0;
+  do {
+    ret = qemu_chr_fe_read_all(&s->chr, (uint8_t *)&msg + n,
+                               sizeof(msg) - n);
+    if (ret < 0) {
+      if (ret == -EINTR) {
+        continue;
+      }
+      error_setg_errno(errp, -ret, "read from server failed");
+      return INT64_MIN;
+    }
+    n += ret;
+  } while (n < sizeof(msg));
+
+  *pfd = qemu_chr_fe_get_msgfd(&s->chr);
+  return le64_to_cpu(msg);
+}
+
+static void gicv3_read(void *opaque, const uint8_t *buf, int size)
+{
+  GICv3State *s = opaque;
+  Error *err = NULL;
+  int fd;
+  int64_t msg;
+
+  assert(size >= 0 && s->msg_buffered_bytes + size <= sizeof(s->msg_buf));
+  memcpy((unsigned char *)&s->msg_buf + s->msg_buffered_bytes, buf, size);
+  s->msg_buffered_bytes += size;
+  if (s->msg_buffered_bytes < sizeof(s->msg_buf)) {
+    return;
+  }
+  msg = le64_to_cpu(s->msg_buf);
+  
+  
+  s->msg_buffered_bytes = 0;
+
+  fd = qemu_chr_fe_get_msgfd(&s->chr);
+
+  process_msg(s, msg, fd, &err);
+  if (err) {
+    error_report_err(err);
+  }
+}
+
+static int gicv3_can_receive(void *opaque)
+{
+  GICv3State *s = opaque;
+
+  assert(s->msg_buffered_bytes < sizeof(s->msg_buf));
+  return sizeof(s->msg_buf) - s->msg_buffered_bytes;
+}
+
+static void gicv3_send_interrupt(void *opaque, int target)
+{
+    if (target > 1) {
+        printf("target is too large\n");
+        return;
+    }
+    int recv_buf;
+    GICv3State *s = opaque;
+    event_notifier_set(&s->eventfd[target]);
+    read(s->ipi_fifo_fd, &recv_buf, sizeof(recv_buf));
+    if (recv_buf != 0xdead) {
+        printf("Data received is %x instead of 0xdead for arm!\n", recv_buf);
+    }
+}
+
+
+static void gicv3_recv_setup(GICv3State *s, Error **errp)
+{
+  Error *err = NULL;
+  int64_t msg;
+  int fd;
+
+  msg = gicv3_recv_msg(s, &fd, &err);
+  if (err) {
+    error_propagate(errp, err);
+    return;
+  }
+  if (msg != 0x0) {
+    error_setg(errp, "server sent version %" PRId64 ", expecting %d",
+               msg, 0x0);
+    return;
+  }
+
+  //if (fd != -1) {
+  //  error_setg(errp, "server sent invalid version message");
+  //  return;
+  //}
+
+
+  /*
+   * vintc-server sends the remaining initial messages in a fixed
+   * order, but the device has always accepted them in any order.
+   * Stay as compatible as practical, just in case people use
+   * servers that behave differently.
+   */
+
+  /*
+   * vintc_device_spec.txt has always required the ID message
+   * right here, and vintc-server has always complied.  However,
+   * older versions of the device accepted it out of order, but
+   * broke when an interrupt setup message arrived before it.
+   */
+  msg = gicv3_recv_msg(s, &fd, &err);
+  if (err) {
+    error_propagate(errp, err);
+    return;
+  }
+  //if (fd != -1 || msg < 0 || msg > 1) {
+  //  error_setg(errp, "server sent invalid ID message");
+  //  return;
+  //}
+
+  s->vm_id = msg;
+  
+  /*
+   * Receive more messages until we got shared memory.
+   */
+  do {
+    msg = gicv3_recv_msg(s, &fd, &err);
+    if (err) {
+      error_propagate(errp, err);
+      return;
+    }
+    process_msg(s, msg, fd, &err);
+    if (err) {
+      error_propagate(errp, err);
+      return;
+    }
+  } while (msg != -1);
+}
+
+
+
+
 
 static void gicv3_gicd_no_migration_shift_bug_post_load(GICv3State *cs)
 {
@@ -308,6 +492,8 @@
 static void arm_gicv3_common_realize(DeviceState *dev, Error **errp)
 {
     GICv3State *s = ARM_GICV3_COMMON(dev);
+    ARMGICv3CommonClass *agcc = ARM_GICV3_COMMON_GET_CLASS(s);
+    
     int i;
 
     /* revision property is actually reserved and currently used only in order
@@ -382,6 +568,37 @@
             (i << 8) |
             (last << 4);
     }
+
+    if (!qemu_chr_fe_backend_connected(&s->chr)) {
+        error_setg(errp, "GICv3 requires a backend connected to a character device");
+        return;
+    }
+
+
+    Chardev *chr = qemu_chr_fe_get_driver(&s->chr);
+    if (!chr) {
+        error_setg(errp, "GICv3 requires a backend connected to a character device");
+        return;
+    }
+
+
+    Error *err = NULL;
+    agcc->recv_setup(s, &err);
+    
+    if (err) {
+        error_propagate(errp, err);
+        return;
+    }
+
+    qemu_chr_fe_set_handlers(&s->chr, agcc->can_read_cb,
+                             agcc->read_cb, NULL, NULL, s, NULL, true);
+
+    /* create a named fifo */
+    s->ipi_fifo_name = "/tmp/cross_arch_ipi_fifo";
+    mkfifo(s->ipi_fifo_name, 0666);
+    s->ipi_fifo_fd = open(s->ipi_fifo_name, O_RDWR);
+    //TODO: close the fd
+
 }
 
 static void arm_gicv3_finalize(Object *obj)
@@ -491,6 +708,7 @@
 }
 
 static Property arm_gicv3_common_properties[] = {
+    DEFINE_PROP_CHR("arm-chr", GICv3State, chr),
     DEFINE_PROP_UINT32("num-cpu", GICv3State, num_cpu, 1),
     DEFINE_PROP_UINT32("num-irq", GICv3State, num_irq, 32),
     DEFINE_PROP_UINT32("revision", GICv3State, revision, 3),
@@ -504,12 +722,22 @@
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
     ARMLinuxBootIfClass *albifc = ARM_LINUX_BOOT_IF_CLASS(klass);
+    ARMGICv3CommonClass *agcc = ARM_GICV3_COMMON_CLASS(klass);
 
     dc->reset = arm_gicv3_common_reset;
     dc->realize = arm_gicv3_common_realize;
     device_class_set_props(dc, arm_gicv3_common_properties);
     dc->vmsd = &vmstate_gicv3;
     albifc->arm_linux_init = arm_gic_common_linux_init;
+    
+    agcc->process_msg_disconnect = gicv3_process_msg_disconnect;
+    agcc->process_msg_connect = gicv3_process_msg_connect;
+    agcc->process_msg = process_msg;
+    agcc->recv_msg = gicv3_recv_msg;
+    agcc->read_cb = gicv3_read;
+    agcc->can_read_cb = gicv3_can_receive;
+    agcc->send_interrupt = gicv3_send_interrupt;
+    agcc->recv_setup = gicv3_recv_setup;
 }
 
 static const TypeInfo arm_gicv3_common_type = {
diff -ur archive/stramash/Stramash-QEMU/hw/intc/arm_gicv3_cpuif.c qemu-stramash/hw/intc/arm_gicv3_cpuif.c
--- archive/stramash/Stramash-QEMU/hw/intc/arm_gicv3_cpuif.c	2024-05-13 16:45:02.599798816 +0100
+++ qemu-stramash/hw/intc/arm_gicv3_cpuif.c	2024-04-04 01:17:08.559417796 +0100
@@ -1678,6 +1678,14 @@
         /* The redistributor will check against its own GICR_NSACR as needed */
         gicv3_redist_send_sgi(ocs, grp, irq, ns);
     }
+
+    // if route to target 2 ( not present ) specifically
+    if (!irm && (targetlist == ( 0 ))) {
+        ARMGICv3CommonClass *agcc = ARM_GICV3_COMMON_GET_CLASS(s);
+        //TODO: which target to send interrupt to?
+        agcc->send_interrupt(s, s->vm_id == 1 ? 0 : 1);
+    }
+
 }
 
 static void icc_sgi0r_write(CPUARMState *env, const ARMCPRegInfo *ri,
diff -ur archive/stramash/Stramash-QEMU/hw/intc/arm_gicv3_redist.c qemu-stramash/hw/intc/arm_gicv3_redist.c
--- archive/stramash/Stramash-QEMU/hw/intc/arm_gicv3_redist.c	2024-05-13 16:45:02.599798816 +0100
+++ qemu-stramash/hw/intc/arm_gicv3_redist.c	2024-04-04 01:17:08.559417796 +0100
@@ -561,6 +561,7 @@
     }
 
     if (grp != irqgrp) {
+        printf("irq group %d is not equal to group %d, exiting\n", irqgrp, grp);
         return;
     }
 
@@ -570,6 +571,7 @@
 
         if ((irqgrp == GICV3_G0 && nsaccess < 1) ||
             (irqgrp == GICV3_G1 && nsaccess < 2)) {
+            printf("irq group %d is not equal to nsaccess %d, exiting\n", irqgrp, nsaccess);
             return;
         }
     }
diff -ur archive/stramash/Stramash-QEMU/hw/intc/gicv3_internal.h qemu-stramash/hw/intc/gicv3_internal.h
--- archive/stramash/Stramash-QEMU/hw/intc/gicv3_internal.h	2024-05-13 16:45:02.599798816 +0100
+++ qemu-stramash/hw/intc/gicv3_internal.h	2024-04-04 01:17:08.559417796 +0100
@@ -24,6 +24,8 @@
 #ifndef QEMU_ARM_GICV3_INTERNAL_H
 #define QEMU_ARM_GICV3_INTERNAL_H
 
+#include "qemu/cutils.h"
+#include "qapi/error.h"
 #include "hw/intc/arm_gicv3_common.h"
 
 /* Distributor registers, as offsets from the distributor base address */
@@ -410,4 +412,10 @@
 
 void gicv3_set_gicv3state(CPUState *cpu, GICv3CPUState *s);
 
+
+//TODO: setup interrupt callback
+// vintc.c:325
+
+
+
 #endif /* QEMU_ARM_GICV3_INTERNAL_H */
diff -ur archive/stramash/Stramash-QEMU/hw/Kconfig qemu-stramash/hw/Kconfig
--- archive/stramash/Stramash-QEMU/hw/Kconfig	2024-05-13 16:45:02.507797943 +0100
+++ qemu-stramash/hw/Kconfig	2024-04-04 01:17:08.495417203 +0100
@@ -39,6 +39,7 @@
 source virtio/Kconfig
 source vfio/Kconfig
 source watchdog/Kconfig
+source demo/Kconfig
 
 # arch Kconfig
 source arm/Kconfig
@@ -82,3 +83,4 @@
     select REGISTER
     select CAN_BUS
     select PTIMER
+    select DEMO
diff -ur archive/stramash/Stramash-QEMU/hw/meson.build qemu-stramash/hw/meson.build
--- archive/stramash/Stramash-QEMU/hw/meson.build	2024-05-13 16:45:02.615798967 +0100
+++ qemu-stramash/hw/meson.build	2024-04-04 01:17:08.571417906 +0100
@@ -40,6 +40,7 @@
 subdir('watchdog')
 subdir('xen')
 subdir('xenpv')
+subdir('demo')
 
 subdir('alpha')
 subdir('arm')
diff -ur archive/stramash/Stramash-QEMU/hw/misc/ivshmem.c qemu-stramash/hw/misc/ivshmem.c
--- archive/stramash/Stramash-QEMU/hw/misc/ivshmem.c	2024-05-13 16:45:02.627799081 +0100
+++ qemu-stramash/hw/misc/ivshmem.c	2024-04-04 01:17:08.579417981 +0100
@@ -117,6 +117,8 @@
     /* migration stuff */
     OnOffAuto master;
     Error *migration_blocker;
+
+    uint32_t *shared_reg_ptr;
 };
 
 /* registers for the Inter-VM shared memory device */
@@ -125,8 +127,39 @@
     INTRSTATUS = 4,
     IVPOSITION = 8,
     DOORBELL = 12,
+    SHARED_REG_ADDR = 16,
+    SHARED_REG_SIZE = 20,
+};
+
+enum ivshmem_shared_registers_offset {
+  SHARED_ADDR_OFFSET = 0,
+  SHARED_SIZE_OFFSET = 1,
 };
 
+static void allocate_shared_reg(const char* shared_reg_name, int shared_reg_size, void *opaque) {
+    IVShmemState *s = opaque;
+    int shared_reg_fd = shm_open(shared_reg_name, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
+    if (shared_reg_fd == -1) {
+        printf("allocating shared memory failed\n");
+        g_assert(0);
+    }
+    if (ftruncate(shared_reg_fd, shared_reg_size) == -1) {
+        printf("Ftruncating shared register failed\n");
+        g_assert(0);
+    }
+    s->shared_reg_ptr = (uint32_t *)mmap(NULL, shared_reg_size, PROT_READ | PROT_WRITE, MAP_SHARED, shared_reg_fd, 0);
+}
+
+static uint32_t read_shared_register(void *opaque, size_t offset) {
+    IVShmemState *s = opaque;
+    return s->shared_reg_ptr[offset];
+}
+
+static void write_shared_register(void *opaque, uint32_t write_data, size_t offset) {
+    IVShmemState *s = opaque;
+    s->shared_reg_ptr[offset] = write_data;
+}
+
 static inline uint32_t ivshmem_has_feature(IVShmemState *ivs,
                                                     unsigned int feature) {
     return (ivs->features & (1 << feature));
@@ -206,6 +239,17 @@
                                 vector, dest);
             }
             break;
+
+        case SHARED_REG_ADDR:
+            IVSHMEM_DPRINTF("Writing to shared address register\n");
+            write_shared_register(s, val, SHARED_ADDR_OFFSET);
+            break;
+
+        case SHARED_REG_SIZE:
+            IVSHMEM_DPRINTF("Writing to shared size register\n");
+            write_shared_register(s, val, SHARED_SIZE_OFFSET);
+            break;
+
         default:
             IVSHMEM_DPRINTF("Unhandled write " TARGET_FMT_plx "\n", addr);
     }
@@ -232,6 +276,16 @@
             ret = s->vm_id;
             break;
 
+        case SHARED_REG_ADDR:
+            ret = read_shared_register(s, SHARED_ADDR_OFFSET);
+            IVSHMEM_DPRINTF("read address return value is %d\n", ret);
+            break;
+
+        case SHARED_REG_SIZE:
+            ret = read_shared_register(s, SHARED_SIZE_OFFSET);
+            IVSHMEM_DPRINTF("read size return value is %d\n", ret);
+            break;
+
         default:
             IVSHMEM_DPRINTF("why are we reading " TARGET_FMT_plx "\n", addr);
             ret = 0;
@@ -906,6 +960,8 @@
             return;
         }
     }
+    allocate_shared_reg("/qemu_shared_register_ipi", 32, s);
+
 
     vmstate_register_ram(s->ivshmem_bar2, DEVICE(s));
     pci_register_bar(PCI_DEVICE(s), 2,
diff -ur archive/stramash/Stramash-QEMU/hw/misc/Kconfig qemu-stramash/hw/misc/Kconfig
--- archive/stramash/Stramash-QEMU/hw/misc/Kconfig	2024-05-13 16:45:02.619799005 +0100
+++ qemu-stramash/hw/misc/Kconfig	2024-04-04 01:17:08.571417906 +0100
@@ -186,4 +186,7 @@
 config VIRT_CTRL
     bool
 
+config VINTC
+    bool
+
 source macio/Kconfig
diff -ur archive/stramash/Stramash-QEMU/hw/misc/meson.build qemu-stramash/hw/misc/meson.build
--- archive/stramash/Stramash-QEMU/hw/misc/meson.build	2024-05-13 16:45:02.627799081 +0100
+++ qemu-stramash/hw/misc/meson.build	2024-04-04 01:17:08.579417981 +0100
@@ -42,6 +42,7 @@
 subdir('macio')
 
 softmmu_ss.add(when: 'CONFIG_IVSHMEM_DEVICE', if_true: files('ivshmem.c'))
+softmmu_ss.add(when: 'CONFIG_VINTC', if_true: files('vintc.c'))
 
 softmmu_ss.add(when: 'CONFIG_ALLWINNER_H3', if_true: files('allwinner-h3-ccu.c'))
 specific_ss.add(when: 'CONFIG_ALLWINNER_H3', if_true: files('allwinner-cpucfg.c'))
Only in qemu-stramash/hw/misc: vintc.c
diff -ur archive/stramash/Stramash-QEMU/hw/riscv/virt.c qemu-stramash/hw/riscv/virt.c
--- archive/stramash/Stramash-QEMU/hw/riscv/virt.c	2024-05-13 16:45:02.687799650 +0100
+++ qemu-stramash/hw/riscv/virt.c	2024-04-04 01:17:08.619418350 +0100
@@ -57,7 +57,8 @@
     [VIRT_FW_CFG] =      { 0x10100000,          0x18 },
     [VIRT_FLASH] =       { 0x20000000,     0x4000000 },
     [VIRT_PCIE_ECAM] =   { 0x30000000,    0x10000000 },
-    [VIRT_PCIE_MMIO] =   { 0x40000000,    0x40000000 },
+    [VIRT_PCIE_MMIO] =   { 0x40000000,    0x30000000 },
+    [VIRT_SHARED_MEM] =  { 0x70000000,    0x01000000 },
     [VIRT_DRAM] =        { 0x80000000,           0x0 },
 };
 
@@ -537,6 +538,7 @@
     RISCVVirtState *s = RISCV_VIRT_MACHINE(machine);
     MemoryRegion *system_memory = get_system_memory();
     MemoryRegion *main_mem = g_new(MemoryRegion, 1);
+    MemoryRegion *share_mem = g_new(MemoryRegion, 1);
     MemoryRegion *mask_rom = g_new(MemoryRegion, 1);
     char *plic_hart_config, *soc_name;
     size_t plic_hart_config_len;
@@ -659,6 +661,15 @@
     memory_region_add_subregion(system_memory, memmap[VIRT_DRAM].base,
         main_mem);
 
+    memory_region_init_ram_from_file(share_mem, NULL, 
+                            "riscv_virt_board.shared-ram",
+                            memmap[VIRT_SHARED_MEM].size, 0, 
+                            RAM_SHARED, "/dev/shm/share", 
+                            false,
+                            &error_fatal);
+    memory_region_add_subregion(system_memory, 
+                memmap[VIRT_SHARED_MEM].base, share_mem);
+
     /* create device tree */
     create_fdt(s, memmap, machine->ram_size, machine->kernel_cmdline,
                riscv_is_32bit(&s->soc[0]));
Only in qemu-stramash: .idea
diff -ur archive/stramash/Stramash-QEMU/include/hw/arm/boot.h qemu-stramash/include/hw/arm/boot.h
--- archive/stramash/Stramash-QEMU/include/hw/arm/boot.h	2024-05-13 16:45:02.767800408 +0100
+++ qemu-stramash/include/hw/arm/boot.h	2024-04-04 01:17:08.675418869 +0100
@@ -115,6 +115,7 @@
      * required by the Linux booting ABI before the switch to non-secure.
      */
     bool secure_board_setup;
+    hwaddr raw_mem_start_addr;
 
     arm_endianness endianness;
 };
diff -ur archive/stramash/Stramash-QEMU/include/hw/arm/virt.h qemu-stramash/include/hw/arm/virt.h
--- archive/stramash/Stramash-QEMU/include/hw/arm/virt.h	2024-05-13 16:45:02.767800408 +0100
+++ qemu-stramash/include/hw/arm/virt.h	2024-04-04 01:17:08.675418869 +0100
@@ -79,9 +79,13 @@
     VIRT_PCIE_ECAM,
     VIRT_PLATFORM_BUS,
     VIRT_GPIO,
+    VIRT_SECURE_GPIO,
     VIRT_SECURE_UART,
     VIRT_SECURE_MEM,
-    VIRT_SECURE_GPIO,
+    VIRT_SHARED_MEM,
+    VIRT_VINTC,
+    VIRT_PERF_MEM,
+    VIRT_STRAMASH_GPIO,
     VIRT_PCDIMM_ACPI,
     VIRT_ACPI_GED,
     VIRT_NVDIMM_ACPI,
diff -ur archive/stramash/Stramash-QEMU/include/hw/core/cpu.h qemu-stramash/include/hw/core/cpu.h
--- archive/stramash/Stramash-QEMU/include/hw/core/cpu.h	2024-05-13 16:45:02.771800446 +0100
+++ qemu-stramash/include/hw/core/cpu.h	2024-04-04 01:17:08.679418906 +0100
@@ -434,6 +434,9 @@
 
     /* track IOMMUs whose translations we've cached in the TCG TLB */
     GArray *iommu_notifiers;
+
+    bool pending_ipi;
+    bool sync;
 };
 
 typedef QTAILQ_HEAD(CPUTailQ, CPUState) CPUTailQ;
diff -ur archive/stramash/Stramash-QEMU/include/hw/core/tcg-cpu-ops.h qemu-stramash/include/hw/core/tcg-cpu-ops.h
--- archive/stramash/Stramash-QEMU/include/hw/core/tcg-cpu-ops.h	2024-05-13 16:45:02.771800446 +0100
+++ qemu-stramash/include/hw/core/tcg-cpu-ops.h	2024-04-04 01:17:08.679418906 +0100
@@ -47,6 +47,8 @@
     void (*do_interrupt)(CPUState *cpu);
     /**
      * @tlb_fill: Handle a softmmu tlb miss or user-only address fault
+     * 
+     * TODO: look at me
      *
      * For system mode, if the access is valid, call tlb_set_page
      * and return true; if the access is invalid, and probe is
diff -ur archive/stramash/Stramash-QEMU/include/hw/i386/apic_internal.h qemu-stramash/include/hw/i386/apic_internal.h
--- archive/stramash/Stramash-QEMU/include/hw/i386/apic_internal.h	2024-05-13 16:45:02.775800484 +0100
+++ qemu-stramash/include/hw/i386/apic_internal.h	2024-04-04 01:17:08.679418906 +0100
@@ -21,6 +21,8 @@
 #ifndef QEMU_APIC_INTERNAL_H
 #define QEMU_APIC_INTERNAL_H
 
+#include "qemu/event_notifier.h"
+#include "chardev/char-fe.h"
 #include "cpu.h"
 #include "exec/memory.h"
 #include "qemu/timer.h"
@@ -148,6 +150,17 @@
      * device, but it's convenient to have it here for now.
      */
     void (*send_msi)(MSIMessage *msi);
+    
+    void (*process_msg_disconnect)(APICCommonState *s, uint16_t posn,Error **errp);
+    void (*process_msg_connect)(APICCommonState *s, uint16_t posn, int fd, Error **errp);
+    void (*process_msg)(APICCommonState *s, int64_t msg, int fd, Error **errp);
+    int64_t (*recv_msg)(APICCommonState *s, int *pfd, Error **errp);
+    void (*read_cb)(void *opaque, const uint8_t *buffer, int size);
+    int (*can_read_cb)(void *opaque);
+    void (*send_interrupt)(void * opaque, int target);
+    void (*recv_setup)(APICCommonState *s, Error **errp);
+    void (*interrupt_cb)(void *opaque);
+
 };
 
 struct APICCommonState {
@@ -187,6 +200,15 @@
     DeviceState *vapic;
     hwaddr vapic_paddr; /* note: persistence via kvmvapic */
     bool legacy_instance_id;
+
+    CharBackend chr;
+    EventNotifier eventfd[2];
+    uint64_t msg_buf; // buffer for messages
+    int msg_buffered_bytes; // number in msg_buf used
+    int vm_id;
+
+    const char* ipi_fifo_path;
+    int ipi_fifo_fd;
 };
 
 typedef struct VAPICState {
diff -ur archive/stramash/Stramash-QEMU/include/hw/intc/arm_gicv3_common.h qemu-stramash/include/hw/intc/arm_gicv3_common.h
--- archive/stramash/Stramash-QEMU/include/hw/intc/arm_gicv3_common.h	2024-05-13 16:45:02.779800522 +0100
+++ qemu-stramash/include/hw/intc/arm_gicv3_common.h	2024-04-04 01:17:08.683418943 +0100
@@ -24,6 +24,8 @@
 #ifndef HW_ARM_GICV3_COMMON_H
 #define HW_ARM_GICV3_COMMON_H
 
+#include "qemu/event_notifier.h"
+#include "chardev/char-fe.h"
 #include "hw/sysbus.h"
 #include "hw/intc/arm_gic_common.h"
 #include "qom/object.h"
@@ -249,6 +251,15 @@
     uint32_t gicd_nsacr[DIV_ROUND_UP(GICV3_MAXIRQ, 16)];
 
     GICv3CPUState *cpu;
+
+    CharBackend chr;
+    EventNotifier eventfd[2];
+    uint64_t msg_buf; // buffer for messages
+    int msg_buffered_bytes; // number in msg_buf used
+    int vm_id;
+
+    const char *ipi_fifo_name;
+    int ipi_fifo_fd;
 };
 
 #define GICV3_BITMAP_ACCESSORS(BMP)                                     \
@@ -290,6 +301,15 @@
 
     void (*pre_save)(GICv3State *s);
     void (*post_load)(GICv3State *s);
+    void (*process_msg_disconnect)(GICv3State *s, uint16_t posn, Error **errp);
+    void (*process_msg_connect)(GICv3State *s, uint16_t posn, int fd, Error **errp);
+    void (*process_msg)(GICv3State *s, int64_t msg, int fd, Error **errp);
+    int64_t (*recv_msg)(GICv3State *s, int *pfd, Error **errp);
+    void (*read_cb)(void *opaque, const uint8_t *buffer, int size);
+    int (*can_read_cb)(void *opaque);
+    void (*send_interrupt)(void * opaque, int target);
+    void (*recv_setup)(GICv3State *s, Error **errp);
+    void (*interrupt_cb)(void *opaque);
 };
 
 void gicv3_init_irqs_and_mmio(GICv3State *s, qemu_irq_handler handler,
Only in qemu-stramash/include/hw/misc: vintc.h
diff -ur archive/stramash/Stramash-QEMU/include/hw/riscv/virt.h qemu-stramash/include/hw/riscv/virt.h
--- archive/stramash/Stramash-QEMU/include/hw/riscv/virt.h	2024-05-13 16:45:02.799800711 +0100
+++ qemu-stramash/include/hw/riscv/virt.h	2024-04-04 01:17:08.699419091 +0100
@@ -59,7 +59,8 @@
     VIRT_DRAM,
     VIRT_PCIE_MMIO,
     VIRT_PCIE_PIO,
-    VIRT_PCIE_ECAM
+    VIRT_PCIE_ECAM,
+    VIRT_SHARED_MEM,
 };
 
 enum {
diff -ur archive/stramash/Stramash-QEMU/include/qemu/plugin.h qemu-stramash/include/qemu/plugin.h
--- archive/stramash/Stramash-QEMU/include/qemu/plugin.h	2024-05-13 16:45:02.831801015 +0100
+++ qemu-stramash/include/qemu/plugin.h	2024-04-04 01:17:08.719419276 +0100
@@ -12,7 +12,7 @@
 #include "qemu/error-report.h"
 #include "qemu/queue.h"
 #include "qemu/option.h"
-
+#include "sysemu/cpu-timers.h"
 /*
  * Events that plugins can subscribe to.
  */
diff -ur archive/stramash/Stramash-QEMU/include/qemu/plugin-memory.h qemu-stramash/include/qemu/plugin-memory.h
--- archive/stramash/Stramash-QEMU/include/qemu/plugin-memory.h	2024-05-13 16:45:02.831801015 +0100
+++ qemu-stramash/include/qemu/plugin-memory.h	2024-04-04 01:17:08.719419276 +0100
@@ -23,6 +23,11 @@
     } v;
 };
 
+struct qemu_plugin_page_counter {
+    uint64_t tlb_miss_counter;
+    uint64_t page_fault_counter;
+};
+
 /**
  * tlb_plugin_lookup: query last TLB lookup
  * @cpu: cpu environment
@@ -37,4 +42,6 @@
 bool tlb_plugin_lookup(CPUState *cpu, target_ulong addr, int mmu_idx,
                        bool is_store, struct qemu_plugin_hwaddr *data);
 
+void tlb_plugin_read_counters(struct qemu_plugin_page_counter *ctr);
+
 #endif /* _PLUGIN_MEMORY_H_ */
diff -ur archive/stramash/Stramash-QEMU/include/qemu/qemu-plugin.h qemu-stramash/include/qemu/qemu-plugin.h
--- archive/stramash/Stramash-QEMU/include/qemu/qemu-plugin.h	2024-05-13 16:45:02.831801015 +0100
+++ qemu-stramash/include/qemu/qemu-plugin.h	2024-04-04 01:17:08.719419276 +0100
@@ -402,6 +402,7 @@
 typedef uint32_t qemu_plugin_meminfo_t;
 /** struct qemu_plugin_hwaddr - opaque hw address handle */
 struct qemu_plugin_hwaddr;
+struct qemu_plugin_page_counter;
 
 /**
  * qemu_plugin_mem_size_shift() - get size of access
@@ -448,6 +449,7 @@
 struct qemu_plugin_hwaddr *qemu_plugin_get_hwaddr(qemu_plugin_meminfo_t info,
                                                   uint64_t vaddr);
 
+struct qemu_plugin_page_counter *qemu_plugin_get_page_counter(void)                                                                                                                                               ;
 /*
  * The following additional queries can be run on the hwaddr structure to
  * return information about it - namely whether it is for an IO access and the
@@ -485,6 +487,7 @@
                              qemu_plugin_meminfo_t info, uint64_t vaddr,
                              void *userdata);
 
+
 void qemu_plugin_register_vcpu_mem_cb(struct qemu_plugin_insn *insn,
                                       qemu_plugin_vcpu_mem_cb_t cb,
                                       enum qemu_plugin_cb_flags flags,
@@ -555,4 +558,10 @@
  */
 void qemu_plugin_outs(const char *string);
 
+
+//Stramash
+uint64_t qemu_plugin_get_icount(void);
+uint64_t qemu_plugin_get_bias(void);
+void qemu_plugin_feedback(uint64_t);
+void qemu_plugin_set(uint64_t);
 #endif /* QEMU_PLUGIN_API_H */
diff -ur archive/stramash/Stramash-QEMU/include/sysemu/cpu-timers.h qemu-stramash/include/sysemu/cpu-timers.h
--- archive/stramash/Stramash-QEMU/include/sysemu/cpu-timers.h	2024-05-13 16:45:02.839801090 +0100
+++ qemu-stramash/include/sysemu/cpu-timers.h	2024-04-04 01:17:08.727419350 +0100
@@ -12,6 +12,7 @@
 
 #include "qemu/timer.h"
 
+// look at me!
 /* init the whole cpu timers API, including icount, ticks, and cpu_throttle */
 void cpu_timers_init(void);
 
@@ -42,7 +43,14 @@
 
 /* return the virtual CPU time in ns, based on the instruction counter. */
 int64_t icount_get(void);
-/*
+
+//Stramash
+int64_t icount_get_bias(void);
+int64_t icount_get_only(void);
+void icount_feedback(int64_t);
+//---------------------------------
+/* 
+ * look at me!
  * convert an instruction counter value to ns, based on the icount shift.
  * This shift is set as a fixed value with the icount "shift" option
  * (precise mode), or it is constantly approximated and corrected at
Only in qemu-stramash: log_for_change
diff -ur archive/stramash/Stramash-QEMU/Makefile qemu-stramash/Makefile
--- archive/stramash/Stramash-QEMU/Makefile	2024-05-13 16:45:02.375796692 +0100
+++ qemu-stramash/Makefile	2024-04-04 01:17:08.371416056 +0100
@@ -177,7 +177,7 @@
 
 include $(SRC_PATH)/tests/Makefile.include
 
-all: recurse-all
+all: recurse-all plugins
 
 ROM_DIRS = $(addprefix pc-bios/, $(ROMS))
 ROM_DIRS_RULES=$(foreach t, all clean, $(addsuffix /$(t), $(ROM_DIRS)))
@@ -219,7 +219,7 @@
 	rm -f roms/seabios/config.mak roms/vgabios/config.mak
 	rm -f qemu-plugins-ld.symbols qemu-plugins-ld64.symbols
 	rm -f *-config-target.h *-config-devices.mak *-config-devices.h
-	rm -rf meson-private meson-logs meson-info compile_commands.json
+	rm -rf meson-private meson-logs meson-info
 	rm -f Makefile.ninja Makefile.mtest build.ninja.stamp meson.stamp
 	rm -f config.log
 	rm -f linux-headers/asm
diff -ur archive/stramash/Stramash-QEMU/meson.build qemu-stramash/meson.build
--- archive/stramash/Stramash-QEMU/meson.build	2024-05-13 16:45:02.895801621 +0100
+++ qemu-stramash/meson.build	2024-04-04 01:17:08.767419720 +0100
@@ -1996,13 +1996,19 @@
 foreach d, list : modules
   foreach m, module_ss : list
     if enable_modules and targetos != 'windows'
-      module_ss = module_ss.apply(config_all, strict: false)
-      sl = static_library(d + '-' + m, [genh, module_ss.sources()],
-                          dependencies: [modulecommon, module_ss.dependencies()], pic: true)
+      module_dn = module_ss.apply(config_all, strict: false)
+      sl = static_library(d + '-' + m, [genh, module_dn.sources()],
+                          dependencies: [modulecommon, module_dn.dependencies()], pic: true)
       if d == 'block'
         block_mods += sl
       else
-        softmmu_mods += sl
+        # we only build 2 non-block modules as modules: it is the gui part
+        if d + '-' + m in [ 'ui-gtk', 'ui-sdl', 'audio-pa' ]
+          softmmu_mods += sl
+        else
+          warning('Compiling module statically: ' + d + '-' + m)
+          softmmu_ss.add_all(module_ss)
+        endif
       endif
     else
       if d == 'block'
@@ -2371,6 +2377,7 @@
                install: true)
   endif
 
+  
   if 'CONFIG_IVSHMEM' in config_host
     subdir('contrib/ivshmem-client')
     subdir('contrib/ivshmem-server')
Only in qemu-stramash: min.sh
diff -ur archive/stramash/Stramash-QEMU/plugins/api.c qemu-stramash/plugins/api.c
--- archive/stramash/Stramash-QEMU/plugins/api.c	2024-05-13 16:45:03.047803062 +0100
+++ qemu-stramash/plugins/api.c	2024-04-04 01:17:08.895420905 +0100
@@ -38,6 +38,8 @@
 #include "qemu/plugin.h"
 #include "cpu.h"
 #include "sysemu/sysemu.h"
+//FOR STRAMASH TIMING MODEL
+#include "sysemu/cpu-timers.h"
 #include "tcg/tcg.h"
 #include "exec/exec-all.h"
 #include "exec/ram_addr.h"
@@ -266,6 +268,7 @@
 
 #ifdef CONFIG_SOFTMMU
 static __thread struct qemu_plugin_hwaddr hwaddr_info;
+static __thread struct qemu_plugin_page_counter tlb_counter_info;
 #endif
 
 struct qemu_plugin_hwaddr *qemu_plugin_get_hwaddr(qemu_plugin_meminfo_t info,
@@ -288,6 +291,13 @@
 #endif
 }
 
+struct qemu_plugin_page_counter *qemu_plugin_get_page_counter(void)
+{
+    tlb_plugin_read_counters(&tlb_counter_info);
+    return &tlb_counter_info;
+}
+
+
 bool qemu_plugin_hwaddr_is_io(const struct qemu_plugin_hwaddr *haddr)
 {
 #ifdef CONFIG_SOFTMMU
@@ -311,8 +321,13 @@
                 error_report("Bad ram pointer %"PRIx64"", haddr->v.ram.hostaddr);
                 abort();
             }
+            //if (block->mr->addr < 0x0f300000ULL) {
+            //    printf("block offset is %lx\n", block->offset);
+            //    printf("offset is %lx\n", offset);
+            //    printf("mr address is %lx\n", block->mr->addr);
+            //}
 
-            return block->offset + offset + block->mr->addr;
+            return block->mr->addr + offset;
         } else {
             MemoryRegionSection *mrs = haddr->v.io.section;
             return haddr->v.io.offset + mrs->mr->addr;
@@ -379,3 +394,20 @@
 {
     qemu_log_mask(CPU_LOG_PLUGIN, "%s", string);
 }
+uint64_t qemu_plugin_get_icount(void)
+{
+	return icount_get_only();
+}
+uint64_t qemu_plugin_get_bias(void)
+{
+	return icount_get_bias();
+}
+void qemu_plugin_feedback(uint64_t feedback)
+{
+    icount_feedback(feedback);
+}
+
+
+
+
+
diff -ur archive/stramash/Stramash-QEMU/plugins/qemu-plugins.symbols qemu-stramash/plugins/qemu-plugins.symbols
--- archive/stramash/Stramash-QEMU/plugins/qemu-plugins.symbols	2024-05-13 16:45:03.047803062 +0100
+++ qemu-stramash/plugins/qemu-plugins.symbols	2024-04-04 01:17:08.895420905 +0100
@@ -31,6 +31,7 @@
   qemu_plugin_mem_is_big_endian;
   qemu_plugin_mem_is_store;
   qemu_plugin_get_hwaddr;
+  qemu_plugin_get_page_counter;
   qemu_plugin_hwaddr_is_io;
   qemu_plugin_hwaddr_to_raddr;
   qemu_plugin_vcpu_for_each;
diff -ur archive/stramash/Stramash-QEMU/qom/object.c qemu-stramash/qom/object.c
--- archive/stramash/Stramash-QEMU/qom/object.c	2024-05-13 16:45:03.067803252 +0100
+++ qemu-stramash/qom/object.c	2024-04-04 01:17:09.375425347 +0100
@@ -314,6 +314,12 @@
         int i;
 
         g_assert(parent->class_size <= ti->class_size);
+        if (!(parent->instance_size <= ti->instance_size)) {
+          printf("Name of parent is %s\n", parent->name);
+          printf("Error: size of parent instance size is %lu\n", parent->instance_size);
+          printf("Error name of self is %s\n", ti->name);
+          printf("Error: size of self instance is %lu\n", ti->instance_size);
+        }
         g_assert(parent->instance_size <= ti->instance_size);
         memcpy(ti->class, parent->class, parent->class_size);
         ti->class->interfaces = NULL;
Only in qemu-stramash/scripts: aarch64-another.sh
Only in qemu-stramash/scripts: aarch64-char-client.sh
Only in qemu-stramash/scripts: aarch64-char-server.sh
Only in qemu-stramash/scripts: aarch64-debug.sh
Only in qemu-stramash/scripts: aarch64-kernel.sh
Only in qemu-stramash/scripts: aarch64-monitor.sh
Only in qemu-stramash/scripts: aarch64-popcorn.sh
Only in qemu-stramash/scripts: aarch64-start.sh
Only in qemu-stramash/scripts: aarch64-tap.sh
Only in qemu-stramash/scripts: aarch64-vintc-other.sh
Only in qemu-stramash/scripts: aarch64-vintc.sh
Only in qemu-stramash/scripts: chr-server.sh
Only in qemu-stramash/scripts: cross_serv.sh
Only in qemu-stramash/scripts: .gdbinit
Only in qemu-stramash/scripts: gmon.out
Only in qemu-stramash/scripts: ivsh-server.sh
Only in qemu-stramash/scripts: riscv64-start.sh
Only in qemu-stramash/scripts: x64-client.sh
Only in qemu-stramash/scripts: x64-debian.sh
Only in qemu-stramash/scripts: x64-ivsh.sh
Only in qemu-stramash/scripts: x64-kernel.sh
Only in qemu-stramash/scripts: x64-monitor.sh
Only in qemu-stramash/scripts: x64-popcorn.sh
Only in qemu-stramash/scripts: x64-start.sh
Only in qemu-stramash/scripts: x64-test.sh
Only in qemu-stramash/scripts: x64-trace.sh
Only in qemu-stramash/slirp: build-aux
Only in qemu-stramash/slirp: CHANGELOG.md
Only in qemu-stramash/slirp: .clang-format
Only in qemu-stramash/slirp: COPYRIGHT
Only in qemu-stramash/slirp: .git
Only in qemu-stramash/slirp: .gitignore
Only in qemu-stramash/slirp: .gitlab-ci.yml
Only in qemu-stramash/slirp: .gitpublish
Only in qemu-stramash/slirp: Makefile
Only in qemu-stramash/slirp: meson.build
Only in qemu-stramash/slirp: README.md
Only in qemu-stramash/slirp: src
diff -ur archive/stramash/Stramash-QEMU/softmmu/icount.c qemu-stramash/softmmu/icount.c
--- archive/stramash/Stramash-QEMU/softmmu/icount.c	2024-05-13 16:45:03.091803479 +0100
+++ qemu-stramash/softmmu/icount.c	2024-04-20 18:32:05.160433092 +0100
@@ -57,7 +57,7 @@
  * 2 = Runtime adaptive algorithm to compute shift
  */
 int use_icount;
-
+// static int hehehe = 0;
 static void icount_enable_precise(void)
 {
     use_icount = 1;
@@ -69,9 +69,9 @@
 }
 
 /*
- * The current number of executed instructions is based on what we
- * originally budgeted minus the current state of the decrementing
- * icount counters in extra/u16.low.
+    * The current number of executed instructions is based on what we
+    * originally budgeted minus the current state of the decrementing
+    * icount counters in extra/u16.low.
  */
 static int64_t icount_get_executed(CPUState *cpu)
 {
@@ -86,9 +86,29 @@
  */
 static void icount_update_locked(CPUState *cpu)
 {
+    // uint64_t ipi_offset  = 0;
+    // if (cpu->pending_ipi) {
+    //     printf("add ipi\n");
+    //     ipi_offset = 17500; //for NO-MSG and Stramash
+	// 	//ipi_offset = 250000; //for TCP
+    //     cpu->pending_ipi = false;
+    // }
     int64_t executed = icount_get_executed(cpu);
     cpu->icount_budget -= executed;
-
+    // uint64_t sync_offset = 0;
+//     if (cpu->sync) {
+//        sync_offset = executed;
+// //	   printf("%lx %lx \n",timers_state.qemu_icount, executed + ipi_offset - sync_offset);
+
+//     }
+	// if (ipi_offset == 175000)
+	// {
+	// 	hehehe =1 ;
+	// 	// icount_sleep = false;
+	// }
+    // qatomic_set_i64(&timers_state.qemu_icount,
+    //                 timers_state.qemu_icount + executed + ipi_offset - sync_offset);
+    // printf("executed: %ld\n", executed);
     qatomic_set_i64(&timers_state.qemu_icount,
                     timers_state.qemu_icount + executed);
 }
@@ -127,8 +147,21 @@
 {
     int64_t icount = icount_get_raw_locked();
     return qatomic_read_i64(&timers_state.qemu_icount_bias) +
-        icount_to_ns(icount);
+	//Stramash, what if we fucked the icount_bias? 
+    icount_to_ns(icount);
 }
+//Stramash 
+static int64_t icount_bias_get_locked(void)
+{
+    return qatomic_read_i64(&timers_state.qemu_icount_bias) >> qatomic_read(&timers_state.icount_time_shift);
+}
+static int64_t icount_get_locked_only(void)
+{
+    return qatomic_read_i64(&timers_state.qemu_icount);
+}
+//Stramash ---
+
+
 
 int64_t icount_get_raw(void)
 {
@@ -142,6 +175,40 @@
 
     return icount;
 }
+//Stramash timing model get bias only
+int64_t icount_get_bias(void)
+{
+	int64_t icount;
+    unsigned start;
+
+    do {
+        start = seqlock_read_begin(&timers_state.vm_clock_seqlock);
+        icount = icount_bias_get_locked();
+    } while (seqlock_read_retry(&timers_state.vm_clock_seqlock, start));
+
+    return icount;
+}
+
+void icount_feedback(int64_t feedback)
+{
+	//we are single cpu, It would be fine maybe? 
+	qatomic_set_i64(&timers_state.qemu_icount,
+                    timers_state.qemu_icount + feedback);
+}
+int64_t icount_get_only(void)
+{
+    // return icount_get_raw();
+    int64_t icount;
+    unsigned start;
+
+    do {
+        start = seqlock_read_begin(&timers_state.vm_clock_seqlock);
+        icount = icount_get_locked_only();
+    } while (seqlock_read_retry(&timers_state.vm_clock_seqlock, start));
+
+    return icount;
+}
+//------------------------------------
 
 /* Return the virtual CPU time, based on the instruction counter.  */
 int64_t icount_get(void)
@@ -185,7 +252,10 @@
                        &timers_state.vm_clock_lock);
     cur_time = REPLAY_CLOCK_LOCKED(REPLAY_CLOCK_VIRTUAL_RT,
                                    cpu_get_clock_locked());
+	//lock the virtual time and return to cur_time
+
     cur_icount = icount_get_locked();
+	//get the current icount
 
     delta = cur_icount - cur_time;
     /* FIXME: This is a very crude algorithm, somewhat prone to oscillation.  */
@@ -199,7 +269,8 @@
     if (delta < 0
         && timers_state.last_delta - ICOUNT_WOBBLE > delta * 2
         && timers_state.icount_time_shift < MAX_ICOUNT_SHIFT) {
-        /* The guest is getting too far behind.  Speed time up.  */
+        /* The guest is getting too far behind.  Speed time up.  */        
+
         qatomic_set(&timers_state.icount_time_shift,
                     timers_state.icount_time_shift + 1);
     }
@@ -207,6 +278,7 @@
     qatomic_set_i64(&timers_state.qemu_icount_bias,
                     cur_icount - (timers_state.qemu_icount
                                   << timers_state.icount_time_shift));
+                            
     seqlock_write_unlock(&timers_state.vm_clock_seqlock,
                          &timers_state.vm_clock_lock);
 }
@@ -228,6 +300,7 @@
 
 int64_t icount_round(int64_t count)
 {
+	//if(hehehe) printf("icount_round\n");
     int shift = qatomic_read(&timers_state.icount_time_shift);
     return (count + (1 << shift) - 1) >> shift;
 }
@@ -249,7 +322,6 @@
     if (warp_start == -1) {
         return;
     }
-
     seqlock_write_lock(&timers_state.vm_clock_seqlock,
                        &timers_state.vm_clock_lock);
     if (runstate_is_running()) {
@@ -302,7 +374,6 @@
     if (!runstate_is_running()) {
         return;
     }
-
     if (replay_mode != REPLAY_MODE_PLAY) {
         if (!all_cpu_threads_idle()) {
             return;
@@ -359,6 +430,10 @@
              * It is useful when we want a deterministic execution time,
              * isolated from host latencies.
              */
+			//if(hehehe){
+				//printf("bias %lx ddl %lx\n",timers_state.qemu_icount_bias, deadline);
+			//	deadline = 10000;
+			//} 
             seqlock_write_lock(&timers_state.vm_clock_seqlock,
                                &timers_state.vm_clock_lock);
             qatomic_set_i64(&timers_state.qemu_icount_bias,
@@ -461,6 +536,8 @@
         return;
     }
 
+    // stramash will never do below
+
     icount_enable_adaptive();
 
     /*
diff -ur archive/stramash/Stramash-QEMU/softmmu/qdev-monitor.c qemu-stramash/softmmu/qdev-monitor.c
--- archive/stramash/Stramash-QEMU/softmmu/qdev-monitor.c	2024-05-13 16:45:03.095803517 +0100
+++ qemu-stramash/softmmu/qdev-monitor.c	2024-04-04 01:17:09.403425606 +0100
@@ -583,6 +583,7 @@
     }
 }
 
+// key part we're missing
 DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
 {
     DeviceClass *dc;
diff -ur archive/stramash/Stramash-QEMU/softmmu/vl.c qemu-stramash/softmmu/vl.c
--- archive/stramash/Stramash-QEMU/softmmu/vl.c	2024-05-13 16:45:03.099803555 +0100
+++ qemu-stramash/softmmu/vl.c	2024-04-04 01:17:09.403425606 +0100
@@ -1204,6 +1204,7 @@
     return qdev_device_help(opts);
 }
 
+//Key part we're missing
 static int device_init_func(void *opaque, QemuOpts *opts, Error **errp)
 {
     DeviceState *dev;
@@ -2295,11 +2296,13 @@
 
 static void create_default_memdev(MachineState *ms, const char *path)
 {
+    printf("MEMDEV: Creating default memory device\n");
     Object *obj;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
 
     obj = object_new(path ? TYPE_MEMORY_BACKEND_FILE : TYPE_MEMORY_BACKEND_RAM);
     if (path) {
+        printf("MEMDEV: Using path");
         object_property_set_str(obj, "mem-path", path, &error_fatal);
     }
     object_property_set_int(obj, "size", ms->ram_size, &error_fatal);
diff -ur archive/stramash/Stramash-QEMU/target/i386/cpu.c qemu-stramash/target/i386/cpu.c
--- archive/stramash/Stramash-QEMU/target/i386/cpu.c	2024-05-13 16:45:03.143803972 +0100
+++ qemu-stramash/target/i386/cpu.c	2024-05-13 12:10:24.367654531 +0100
@@ -16,7 +16,7 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
-
+#include <string.h>
 #include "qemu/osdep.h"
 #include "qemu/units.h"
 #include "qemu/cutils.h"
@@ -4271,6 +4271,8 @@
  */
 static PropValue tcg_default_props[] = {
     { "vme", "off" },
+    { "x2apic", "off" },
+    { "apic", "on" },
     { NULL, NULL },
 };
 
@@ -4280,7 +4282,7 @@
  * none", but this is just for compatibility while libvirt isn't
  * adapted to resolve CPU model versions before creating VMs.
  * See "Runnability guarantee of CPU models" at
- * docs/system/deprecated.rst.
+ * docs/system/precated.rst.
  */
 X86CPUVersion default_cpu_version = 1;
 
@@ -6310,6 +6312,9 @@
                               OBJECT(cpu->apic_state));
     object_unref(OBJECT(cpu->apic_state));
 
+    
+    object_property_parse(OBJECT(cpu->apic_state), "x86-chr", "x86_chr", &error_fatal);
+
     qdev_prop_set_uint32(cpu->apic_state, "id", cpu->apic_id);
     /* TODO: convert to link<> */
     apic = APIC_COMMON(cpu->apic_state);
@@ -6317,6 +6322,7 @@
     apic->apicbase = APIC_DEFAULT_ADDRESS | MSR_IA32_APICBASE_ENABLE;
 }
 
+//TODO: unlike gic, much of the apic code is in here
 static void x86_cpu_apic_realize(X86CPU *cpu, Error **errp)
 {
     APICCommonState *apic;
Only in qemu-stramash/target: sync
Only in qemu-stramash/tests/fp/berkeley-softfloat-3: build
Only in qemu-stramash/tests/fp/berkeley-softfloat-3: COPYING.txt
Only in qemu-stramash/tests/fp/berkeley-softfloat-3: doc
Only in qemu-stramash/tests/fp/berkeley-softfloat-3: .git
Only in qemu-stramash/tests/fp/berkeley-softfloat-3: .gitignore
Only in qemu-stramash/tests/fp/berkeley-softfloat-3: README.html
Only in qemu-stramash/tests/fp/berkeley-softfloat-3: README.md
Only in qemu-stramash/tests/fp/berkeley-softfloat-3: README.txt
Only in qemu-stramash/tests/fp/berkeley-softfloat-3: source
Only in qemu-stramash/tests/fp/berkeley-testfloat-3: build
Only in qemu-stramash/tests/fp/berkeley-testfloat-3: COPYING.txt
Only in qemu-stramash/tests/fp/berkeley-testfloat-3: doc
Only in qemu-stramash/tests/fp/berkeley-testfloat-3: .git
Only in qemu-stramash/tests/fp/berkeley-testfloat-3: .gitignore
Only in qemu-stramash/tests/fp/berkeley-testfloat-3: README.html
Only in qemu-stramash/tests/fp/berkeley-testfloat-3: README.md
Only in qemu-stramash/tests/fp/berkeley-testfloat-3: README.txt
Only in qemu-stramash/tests/fp/berkeley-testfloat-3: source
diff -ur archive/stramash/Stramash-QEMU/tests/plugin/insn.c qemu-stramash/tests/plugin/insn.c
--- archive/stramash/Stramash-QEMU/tests/plugin/insn.c	2024-05-13 16:45:03.299805451 +0100
+++ qemu-stramash/tests/plugin/insn.c	2024-04-04 01:17:09.659427975 +0100
@@ -17,19 +17,43 @@
 QEMU_PLUGIN_EXPORT int qemu_plugin_version = QEMU_PLUGIN_VERSION;
 
 static uint64_t insn_count;
-static bool do_inline;
+static uint8_t icount_on;
+
+static void plugin_init(void)
+{
+    icount_on = 0;
+}
 
 static void vcpu_insn_exec_before(unsigned int cpu_index, void *udata)
 {
-    static uint64_t last_pc;
-    uint64_t this_pc = GPOINTER_TO_UINT(udata);
-    if (this_pc == last_pc) {
-        g_autofree gchar *out = g_strdup_printf("detected repeat execution @ 0x%"
-                                                PRIx64 "\n", this_pc);
-        qemu_plugin_outs(out);
-    }
-    last_pc = this_pc;
-    insn_count++;
+    insn_count += icount_on;
+}
+
+static void vcpu_haddr(unsigned int cpu_index, qemu_plugin_meminfo_t meminfo,
+                       uint64_t vaddr, void *udata)
+{
+    struct qemu_plugin_hwaddr *hwaddr = qemu_plugin_get_hwaddr(meminfo, vaddr);
+//    struct qemu_plugin_page_counter *pgctr = qemu_plugin_get_page_counter();
+    if (!hwaddr || !qemu_plugin_hwaddr_is_io(hwaddr)) {
+        uint64_t off = qemu_plugin_hwaddr_phys_addr(hwaddr);
+        if (off >= 0x1200000000ULL) {
+//            printf("the address for memory access is %llx\n", pgctr->tlb_miss_counter);
+            icount_on = icount_on == 1 ? 0 : 1;
+        }
+        if (off > 0x100000000ULL) {
+            printf("the address for memory access is %lx\n", off);
+            if (qemu_plugin_mem_is_store(meminfo))
+            {
+                printf("this is a memory write\n");
+            }
+            else 
+            {
+                printf("this is a memory read\n");
+            }
+        }
+
+    } 
+    return;
 }
 
 static void vcpu_tb_trans(qemu_plugin_id_t id, struct qemu_plugin_tb *tb)
@@ -40,15 +64,15 @@
     for (i = 0; i < n; i++) {
         struct qemu_plugin_insn *insn = qemu_plugin_tb_get_insn(tb, i);
 
-        if (do_inline) {
-            qemu_plugin_register_vcpu_insn_exec_inline(
-                insn, QEMU_PLUGIN_INLINE_ADD_U64, &insn_count, 1);
-        } else {
             uint64_t vaddr = qemu_plugin_insn_vaddr(insn);
             qemu_plugin_register_vcpu_insn_exec_cb(
                 insn, vcpu_insn_exec_before, QEMU_PLUGIN_CB_NO_REGS,
                 GUINT_TO_POINTER(vaddr));
-        }
+        gpointer udata = (gpointer) (qemu_plugin_insn_vaddr(insn));
+        qemu_plugin_register_vcpu_mem_cb(insn, vcpu_haddr,
+                                         QEMU_PLUGIN_CB_NO_REGS,
+                                         QEMU_PLUGIN_MEM_RW, udata);
+
     }
 }
 
@@ -62,9 +86,7 @@
                                            const qemu_info_t *info,
                                            int argc, char **argv)
 {
-    if (argc && !strcmp(argv[0], "inline")) {
-        do_inline = true;
-    }
+    plugin_init();
 
     qemu_plugin_register_vcpu_tb_trans_cb(id, vcpu_tb_trans);
     qemu_plugin_register_atexit_cb(id, plugin_exit, NULL);
Only in qemu-stramash/ui/keycodemapdb: data
Only in qemu-stramash/ui/keycodemapdb: .git
Only in qemu-stramash/ui/keycodemapdb: LICENSE.BSD
Only in qemu-stramash/ui/keycodemapdb: LICENSE.GPL2
Only in qemu-stramash/ui/keycodemapdb: meson.build
Only in qemu-stramash/ui/keycodemapdb: README
Only in qemu-stramash/ui/keycodemapdb: tests
Only in qemu-stramash/ui/keycodemapdb: thirdparty
Only in qemu-stramash/ui/keycodemapdb: tools
diff -ur archive/stramash/Stramash-QEMU/util/event_notifier-posix.c qemu-stramash/util/event_notifier-posix.c
--- archive/stramash/Stramash-QEMU/util/event_notifier-posix.c	2024-05-13 16:45:03.563807954 +0100
+++ qemu-stramash/util/event_notifier-posix.c	2024-04-04 01:17:09.851429752 +0100
@@ -123,7 +123,7 @@
 {
     int value;
     ssize_t len;
-    char buffer[512];
+    uint64_t buffer;
 
     if (!e->initialized) {
         return 0;
@@ -132,9 +132,9 @@
     /* Drain the notify pipe.  For eventfd, only 8 bytes will be read.  */
     value = 0;
     do {
-        len = read(e->rfd, buffer, sizeof(buffer));
+        len = read(e->rfd, &buffer, sizeof(buffer));
         value |= (len > 0);
-    } while ((len == -1 && errno == EINTR) || len == sizeof(buffer));
+    } while ((len == -1 && errno == EINTR));
 
     return value;
 }
